<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lexical.FileSystem.Abstractions</name>
    </assembly>
    <members>
        <member name="T:Lexical.FileSystem.EntryExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IEntry"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.Length(Lexical.FileSystem.IEntry)">
            <summary>
            File length. -1 if is length is unknown.
            </summary>
            <returns>File length. -1 if is length is unknown.</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsFile(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> represents a file.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsDirectory(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> represents a directory.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.Options(Lexical.FileSystem.IEntry)">
            <summary>
            Get options
            </summary>
            <param name="entry"></param>
            <returns>options or null.</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.EffectiveOptions(Lexical.FileSystem.IEntry)">
            <summary>
            Get effective options
            </summary>
            <param name="entry"></param>
            <returns>options.</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsDrive(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> represents a drive.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.DriveType(Lexical.FileSystem.IEntry)">
            <summary>
            Drive type.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.DriveFreeSpace(Lexical.FileSystem.IEntry)">
            <summary>
            Free space, -1L if unknown.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.DriveSize(Lexical.FileSystem.IEntry)">
            <summary>
            Total size of drive or volume. -1L if unkown.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.DriveLabel(Lexical.FileSystem.IEntry)">
            <summary>
            Label, or null if unknown.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.DriveFormat(Lexical.FileSystem.IEntry)">
            <summary>
            File system format.
            
            Examples:
            <list type="bullet">
                <item>NTFS</item>
                <item>FAT32</item>
            </list>
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsMountPoint(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> represents a mount root.
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.Mounts(Lexical.FileSystem.IEntry)">
            <summary>
            (optional) Mounted filesystem.
            </summary>
            <param name="entry"></param>
            <returns>mounted filesystem or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsAutoMounted(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> is a directory that is automatically mounted.
            </summary>
            <param name="entry"></param>
            <returns>true if automatically mounted</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.IsPackageMount(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> represents the root of a mounted package, such as .zip.
            </summary>
            <param name="entry"></param>
            <returns>true if automatically mounted</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.HasFileAttributes(Lexical.FileSystem.IEntry)">
            <summary>
            Tests if <paramref name="entry"/> has <see cref="M:Lexical.FileSystem.EntryExtensions.FileAttributes(Lexical.FileSystem.IEntry)"/>.
            </summary>
            <returns>true if it has file attributes</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.FileAttributes(Lexical.FileSystem.IEntry)">
            <summary>
            Gets file attributes of <paramref name="entry"/>.
            
            The caller should first test if attributes exist with <see cref="M:Lexical.FileSystem.EntryExtensions.HasFileAttributes(Lexical.FileSystem.IEntry)"/>.
            </summary>
            <returns>file attributes</returns>
        </member>
        <member name="M:Lexical.FileSystem.EntryExtensions.PhysicalPath(Lexical.FileSystem.IEntry)">
            <summary>
            Gets physical (OS) file or directory path of <paramref name="entry"/>.
            </summary>
            <returns>(optional) file path</returns>
        </member>
        <member name="T:Lexical.FileSystem.EventExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IEvent"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EventExtensions.NewPath(Lexical.FileSystem.IEvent)">
            <summary>
            Get NewPath value of <paramref name="event"/> if it's <see cref="T:Lexical.FileSystem.IRenameEvent"/>.
            </summary>
            <param name="event"></param>
            <returns>new path</returns>
            <exception cref="T:System.NotSupportedException">If <paramref name="event"/> is not <see cref="T:Lexical.FileSystem.IRenameEvent"/></exception>
        </member>
        <member name="T:Lexical.FileSystem.IFileProviderDisposable">
            <summary>
            <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/> that implements <see cref="T:System.IDisposable"/>.
            Used to signal both interfaces as return value of methods.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemBrowseExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystemBrowse"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.CanBrowse(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Browse capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true if has Browse capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.CanGetEntry(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Exists capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true if has Exists capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.Browse(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for child entries.
            
            <paramref name="path"/> should end with directory separator character '/', for example "mydir/".
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>
                Returns a snapshot of file and directory entries.
                Note, that the returned array be internally cached by the implementation, and therefore the caller must not modify the array.
            </returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.BrowseAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for child entries.
            
            <paramref name="path"/> should end with directory separator character '/', for example "mydir/".
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>
                Returns a snapshot of file and directory entries.
                Note, that the returned array be internally cached by the implementation, and therefore the caller must not modify the array.
            </returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.GetEntry(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.GetEntryAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.Exists(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Tests if a file or directory exists.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if exists</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.ExistsAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Tests if a file or directory exists.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if exists</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.AssertExists(Lexical.FileSystem.IDirectoryContent)">
            <summary>
            If <see cref="P:Lexical.FileSystem.IDirectoryContent.Exists"/> is false then throws <see cref="T:System.IO.DirectoryNotFoundException"/>.
            </summary>
            <param name="browseResult"></param>
            <returns><paramref name="browseResult"/></returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">If <paramref name="browseResult"/> referes to non-existing path.</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBrowseExtensions.AssertExists(Lexical.FileSystem.IEntry)">
            <summary>
            If <paramref name="entry"/> is null, then throws <see cref="T:System.IO.FileNotFoundException"/>.
            </summary>
            <param name="entry"></param>
            <returns></returns>
            <exception cref="T:System.IO.FileNotFoundException">If <paramref name="entry"/> is null.</exception>
        </member>
        <member name="T:Lexical.FileSystem.BrowseOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IBrowseOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.BrowseOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.BrowseOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.BrowseOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.BrowseOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.BrowseOption">
            <summary>File system options for browse.</summary>
        </member>
        <member name="P:Lexical.FileSystem.BrowseOption.Browse">
            <summary>Browse allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.BrowseOption.NoBrowse">
            <summary>Browse not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.BrowseOption.CanBrowse">
            <summary>Has Browse capability.</summary>
        </member>
        <member name="P:Lexical.FileSystem.BrowseOption.CanGetEntry">
            <summary>Has GetEntry capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.BrowseOption.#ctor(System.Boolean,System.Boolean)">
            <summary>Create file system options for browse.</summary>
        </member>
        <member name="M:Lexical.FileSystem.BrowseOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemCreateDirectoryExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystemCreateDirectory"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemCreateDirectoryExtensions.CanCreateDirectory(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has CreateDirectory capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has CreateDirectory capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemCreateDirectoryExtensions.CreateDirectory(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            
            <paramref name="path"/> should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemCreateDirectoryExtensions.CreateDirectoryTask(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            
            <paramref name="path"/> should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.CreateDirectoryOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.ICreateDirectoryOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.CreateDirectoryOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateDirectoryOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateDirectoryOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateDirectoryOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.CreateDirectoryOption">
            <summary>File system option for creating directories.</summary>
        </member>
        <member name="P:Lexical.FileSystem.CreateDirectoryOption.CreateDirectory">
            <summary>CreateDirectory allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.CreateDirectoryOption.NoCreateDirectory">
            <summary>CreateDirectory not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.CreateDirectoryOption.CanCreateDirectory">
            <summary>Has CreateDirectory capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateDirectoryOption.#ctor(System.Boolean)">
            <summary>Create file system option for creating directories.</summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateDirectoryOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemDeleteExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystemDelete"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemDeleteExtensions.CanDelete(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Delete capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Delete capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemDeleteExtensions.Delete(Lexical.FileSystem.IFileSystem,System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="path"/> is directory, then it should end with directory separator character '/', for example "dir/".
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemDeleteExtensions.DeleteAsync(Lexical.FileSystem.IFileSystem,System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="path"/> is directory, then it should end with directory separator character '/', for example "dir/".
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="filesystem"></param>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.DeleteOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IDeleteOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DeleteOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.DeleteOption">
            <summary>File system option for deleting files and directories.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DeleteOption.Delete">
            <summary>Delete allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DeleteOption.NoDelete">
            <summary>Delete not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DeleteOption.CanDelete">
            <summary>Has Delete capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteOption.#ctor(System.Boolean)">
            <summary>Create file system option for deleting files and directories.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemException">
            <summary>
            FileSystem specific exception. 
            
            Addresses more specific errors situations that generic <see cref="T:System.IO.IOException"/> doesn't cover.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemException.filesystem">
            <summary>
            (optional) Error related filesystem.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemException.path">
            <summary>
            (optional) Error related file path.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemException.FileSystem">
            <summary>
            (optional) Error related filesystem.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemException.Path">
            <summary>
            (optional) Error related file path.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemException.Message">
            <summary>Error message</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemException.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception)">
            <summary>
            Create filesystem exception.
            </summary>
            <param name="filesystem">(optional) error related filesystem</param>
            <param name="path">(optional) error related file path</param>
            <param name="message">Message</param>
            <param name="innerException">(optional) inner exception</param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemException.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Int32)">
            <summary>
            Create filesystem exception.
            </summary>
            <param name="filesystem">(optional) error related filesystem</param>
            <param name="path">(optional) error related file path</param>
            <param name="message">Message</param>
            <param name="hresult"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Deserialize exception.</summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize object data to <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">
            <summary>
            No read access to a file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionNoReadAccess.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create no read access error.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionNoReadAccess.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">
            <summary>
            No write access to a file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionNoWriteAccess.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create no write access error.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionNoWriteAccess.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionEntryExists">
            <summary>
            Entry already exists when not expected
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionEntryExists.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String)">
            <summary>
            Create exception
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="message"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionEntryExists.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionFileExists">
            <summary>
            File exists when not expected
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionFileExists.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create exception
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionFileExists.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionInvalidName">
            <summary>
            Invalid name for file or directory
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionInvalidName.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create exception
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionInvalidName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionDirectoryExists">
            <summary>
            Directory exists when not expected
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionDirectoryExists.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create exception
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionDirectoryExists.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionUtil">
            <summary>
            Utilities for <see cref="T:Lexical.FileSystem.FileSystemException"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionUtil.Set(Lexical.FileSystem.FileSystemException,Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Set the filesystem reference of <paramref name="exception"/>.
            
            This allows filesystem implementations that compose other implementations to update references.
            </summary>
            <param name="exception"></param>
            <param name="filesystem"></param>
            <param name="path"></param>
            <returns>false</returns>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionOptionNotSupported">
            <summary>
            Requested <see cref="T:Lexical.FileSystem.IOption"/> is not supported.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemExceptionOptionNotSupported.Option">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemExceptionOptionNotSupported.OptionType">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOptionNotSupported.#ctor(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Create file system option not supported error.
            </summary>
            <param name="filesystem"></param>
            <param name="path">(optional) a path where the option was applied</param>
            <param name="option">(optional) option instance</param>
            <param name="optionType">The <see cref="T:Lexical.FileSystem.IOption"/> interface that was not supported</param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOptionNotSupported.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported">
            <summary>
            Requested <see cref="T:Lexical.FileSystem.IOptionOperation"/> is not supported.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported.Option">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported.OptionType">
            <summary>
            Subinterface of <see cref="T:Lexical.FileSystem.IOption"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported.OptionOperationType">
            <summary>
            Subinterface of <see cref="T:Lexical.FileSystem.IOptionOperation"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported.#ctor(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,System.Type,System.Type)">
            <summary>
            Create file system option
            </summary>
            <param name="filesystem"></param>
            <param name="path">(optional) a path where the option was applied</param>
            <param name="option">(optional) option instance</param>
            <param name="optionType">The <see cref="T:Lexical.FileSystem.IOption"/> interface type that was not supported</param>
            <param name="optionOperationType">The <see cref="T:Lexical.FileSystem.IOptionOperation"/> interface type that was not supported</param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExceptionOutOfDiskSpace">
            <summary>
            Out of disk space exception
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOutOfDiskSpace.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create exception
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExceptionOutOfDiskSpace.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemFileAttributeExtensions">
            <summary>
            Extension methods for setting FileAttributes on <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            File Attributes are read with <see cref="M:Lexical.FileSystem.IFileSystemBrowse.GetEntry(System.String,Lexical.FileSystem.IOption)"/> and <see cref="T:Lexical.FileSystem.IEntryFileAttributes"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemFileAttributeExtensions.CanSetFileAttribute(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has SetFileAttribute capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true if has SetFileAttribute capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemFileAttributeExtensions.SetFileAttribute(Lexical.FileSystem.IFileSystem,System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemFileAttributeExtensions.SetFileAttributeAsync(Lexical.FileSystem.IFileSystem,System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:Lexical.FileSystem.FileAttributeOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IFileAttributeOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileAttributeOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileAttributeOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileAttributeOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileAttributeOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileAttributeOption">
            <summary>File system options for browse.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileAttributeOption.CanSetFileAttribute">
            <summary>Has SetFileAttribute capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileAttributeOption.#ctor(System.Boolean)">
            <summary>Create file system options for browse.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileAttributeOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemAssignment">
            <summary>The filesystem and option assignment.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.op_Implicit(Lexical.FileSystem.FileSystemAssignment)~System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption}">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.op_Implicit(System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption})~Lexical.FileSystem.FileSystemAssignment">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.op_Equality(Lexical.FileSystem.FileSystemAssignment,Lexical.FileSystem.FileSystemAssignment)">
            <summary>Compare infos</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.op_Inequality(Lexical.FileSystem.FileSystemAssignment,Lexical.FileSystem.FileSystemAssignment)">
            <summary>Compare infos</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.Equals(Lexical.FileSystem.FileSystemAssignment)">
            <summary>Compare infos</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.Equals(System.Object)">
            <summary>Compare infos</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.GetHashCode">
            <summary>Info hashcode</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.ToString">
            <summary>Print info</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignment.FileSystem">
            <summary>(optional) Filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignment.Option">
            <summary>(optional) Overriding option assignment.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignment.Flags">
            <summary>Is flagged as automatically mounted.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemAssignment.#ctor(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption,Lexical.FileSystem.FileSystemAssignmentFlags)">
            <summary>Create filesystem and option assignment.</summary>
            <param name="fileSystem">(optional) file system</param>
            <param name="option">(optional) overriding option assignment</param>
            <param name="flags">(optional) assignment related flags</param>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemMountExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.CanMount(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Is filesystem capable of creating mountpoints.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.CanListMountPoints(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Is filesystem allowed to list mountpoints.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.CanUnmount(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Is filesystem allowed to unmount a mount.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.AutoMounters(Lexical.FileSystem.IOption)">
            <summary>
            Get automounters.
            </summary>
            <param name="filesystemOption"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.Mount(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="filesystem">filesystem</param>
            <param name="mountOption">(optional) options</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.MountAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="filesystem">filesystem</param>
            <param name="mountOption">(optional) options</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.Mount(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem[])">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path"></param>
            <param name="filesystems">filesystem</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.MountAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem[])">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path"></param>
            <param name="filesystems">filesystem</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.Mount(Lexical.FileSystem.IFileSystem,System.String,System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption}[])">
            <summary>
            Mount <paramref name="filesystems"/> at <paramref name="path"/> in the parent filesystem.
            
            If <paramref name="path"/> is already mounted, then replaces previous mount.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="filesystems"></param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.MountAsync(Lexical.FileSystem.IFileSystem,System.String,System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption}[])">
            <summary>
            Mount <paramref name="filesystems"/> at <paramref name="path"/> in the parent filesystem.
            
            If <paramref name="path"/> is already mounted, then replaces previous mount.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="filesystems"></param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.Mount(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="mounts">(optional) filesystem and option infos</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.MountAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="mounts">(optional) filesystem and option infos</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.Unmount(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.UnmountAsync(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="path">path to mount point</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.ListMountPoints(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption)">
            <summary>
            List all mounts.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMountExtensions.ListMountPointsAsync(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption)">
            <summary>
            List all mounts.
            </summary>
            <param name="parentFileSystem"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="T:Lexical.FileSystem.MountOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IMountOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.SubPathOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.ISubPathOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.SubPathOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.SubPathOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.SubPathOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.SubPathOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.SubPathOption">
            <summary>Option for mount path. Use with decorator.</summary>
        </member>
        <member name="P:Lexical.FileSystem.SubPathOption.NoSubPath">
            <summary>No mount path.</summary>
        </member>
        <member name="P:Lexical.FileSystem.SubPathOption.SubPath">
            <summary>Mount path.</summary>
        </member>
        <member name="M:Lexical.FileSystem.SubPathOption.#ctor(System.String)">
            <summary>Create option for mount path.</summary>
        </member>
        <member name="M:Lexical.FileSystem.SubPathOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.MountOption">
            <summary>File system option for mount capabilities.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOption.Mount">
            <summary>Mount is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOption.NoMount">
            <summary>Mount is not allowed</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOption.CanMount">
            <summary>Can filesystem mount other filesystems.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOption.CanUnmount">
            <summary>Is filesystem allowed to unmount a mount.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountOption.CanListMountPoints">
            <summary>Is filesystem allowed to list mountpoints.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountOption.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create file system option for mount capabilities.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemMoveExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMoveExtensions.CanMove(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has local move/rename capability. 
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Move capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMoveExtensions.Move(Lexical.FileSystem.IFileSystem,System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory. 
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemMoveExtensions.MoveAsync(Lexical.FileSystem.IFileSystem,System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory. 
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.MoveOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IMoveOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MoveOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MoveOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MoveOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MoveOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.MoveOption">
            <summary>File system option for move/rename.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MoveOption.Move">
            <summary>Move and rename is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MoveOption.NoMove">
            <summary>Move and rename not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MoveOption.CanMove">
            <summary>Has Move capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MoveOption.#ctor(System.Boolean)">
            <summary>Create file system option for move/rename.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MoveOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemObserverExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverExtensions.CanObserve(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Observe capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Observe capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverExtensions.Observe(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a directory. 
            
            The <paramref name="filter"/> determines the file pattern to observe.
             "*" Matches to any sequence characters within one folder.
             "**" Matches to any sequence characters including directory levels '/'.
             "?" Matches to one and exactly one character.
            
            Examples:
              <list type="bullet">
                <item>"**" is any file in any directory.</item>
                <item>"**/file.txt", to monitor "file.txt" in any subdirectory (excluding root due to missing "/")</item>
                <item>"*" is any set of characters file in one directory. For example "mydir/somefile*.txt"</item>
                <item>"", to monitor changes to the root directory itself, but not its files</item>
                <item>"dir", to monitor the dir itself, but not its files</item>
                <item>"dir/", to monitor the dir itself, but not its files</item>
                <item>"dir/file", to monitor one file "file"</item>
                <item>"dir/*", to monitor files in a dir but not subdirectories</item>
                <item>"dir/**", to monitor files in a dir and its subdirectories</item>
              </list>
            
            The implementation sends the reference to the observer handle in a <see cref="T:Lexical.FileSystem.IStartEvent"/> event before this method returns to caller.
            </summary>
            <param name="filesystem"></param>
            <param name="filter">glob pattern to filter events. "**" means any directory. For example "mydir/**/somefile.txt", or "**" for <paramref name="filter"/> and sub-directories</param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>handle to the observer, dispose to cancel the observe</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverExtensions.ObserveAsync(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a directory. 
            
            The <paramref name="filter"/> determines the file pattern to observe.
             "*" Matches to any sequence characters within one folder.
             "**" Matches to any sequence characters including directory levels '/'.
             "?" Matches to one and exactly one character.
            
            Examples:
              <list type="bullet">
                <item>"**" is any file in any directory.</item>
                <item>"**/file.txt", to monitor "file.txt" in any subdirectory (excluding root due to missing "/")</item>
                <item>"*" is any set of characters file in one directory. For example "mydir/somefile*.txt"</item>
                <item>"", to monitor changes to the root directory itself, but not its files</item>
                <item>"dir", to monitor the dir itself, but not its files</item>
                <item>"dir/", to monitor the dir itself, but not its files</item>
                <item>"dir/file", to monitor one file "file"</item>
                <item>"dir/*", to monitor files in a dir but not subdirectories</item>
                <item>"dir/**", to monitor files in a dir and its subdirectories</item>
              </list>
            
            The implementation sends the reference to the observer handle in a <see cref="T:Lexical.FileSystem.IStartEvent"/> event before this method returns to caller.
            </summary>
            <param name="filesystem"></param>
            <param name="filter">glob pattern to filter events. "**" means any directory. For example "mydir/**/somefile.txt", or "**" for <paramref name="filter"/> and sub-directories</param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>handle to the observer, dispose to cancel the observe</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.ObserverOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IObserveOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserverOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserverOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserverOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.ObserveOption">
            <summary>File system option for observe.</summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserveOption.Observe">
            <summary>Observe is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserveOption.NoObserve">
            <summary>Observe is not allowed</summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserveOption.CanObserve">
            <summary>Has Observe capability.</summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserveOption.#ctor(System.Boolean)">
            <summary>Create file system option for observe.</summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserveOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemOpenExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystemOpen"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CanOpen(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Open capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Open capability. If unspecified, the default value is false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CanRead(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Read capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Read capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CanWrite(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has Write capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has Write capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CanCreateFile(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            Test if <paramref name="filesystemOption"/> has CreateFile capability.
            </summary>
            <param name="filesystemOption"></param>
            <param name="defaultValue">Returned value if option is unspecified</param>
            <returns>true, if has CreateFile capability</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CreateFile(Lexical.FileSystem.IFileSystem,System.String,System.Byte[],Lexical.FileSystem.IOption)">
            <summary>
            Create a new file. If file exists, does nothing.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/file"</param>
            <param name="initialData">(optional) initial data to write</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.CreateFileAsync(Lexical.FileSystem.IFileSystem,System.String,System.Byte[],Lexical.FileSystem.IOption)">
            <summary>
            Create a new file. If file exists, does nothing.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/file"</param>
            <param name="initialData">(optional) initial data to write</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.Open(Lexical.FileSystem.IFileSystem,System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOpenExtensions.OpenAsync(Lexical.FileSystem.IFileSystem,System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="T:Lexical.FileSystem.OpenOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IOpenOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.OpenOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.OpenOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.OpenOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.OpenOption">
            <summary>File system options for open, create, read and write files.</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.OpenReadWriteCreate">
            <summary>Open, Read, Write, Create</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.OpenReadWrite">
            <summary>Open, Read, Write</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.OpenRead">
            <summary>Open, Read</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.NoOpen">
            <summary>No access</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.CanOpen">
            <summary>Can open file</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.CanRead">
            <summary>Can open file for reading(</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.CanWrite">
            <summary>Can open file for writing.</summary>
        </member>
        <member name="P:Lexical.FileSystem.OpenOption.CanCreateFile">
            <summary>Can open and create file.</summary>
        </member>
        <member name="M:Lexical.FileSystem.OpenOption.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create file system options for open, create, read and write files.</summary>
        </member>
        <member name="M:Lexical.FileSystem.OpenOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.IEntry">
            <summary>
            Entry that represents a node of a <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            The entry represents the snapshot state at the time of creation.
            
            See <see cref="T:Lexical.FileSystem.IEntry"/> sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.IFileEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.IDirectoryEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.IDriveEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.IMountEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.IEntryOptions"/></item>
                <item><see cref="T:Lexical.FileSystem.IEntryFileAttributes"/></item>
                <item><see cref="T:Lexical.FileSystem.IEntryPhysicalPath"/></item>
                <item><see cref="T:Lexical.FileSystem.IEntryDecoration"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntry.FileSystem">
            <summary>
            (optional) Associated file system.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntry.Path">
            <summary>
            Path that is relative to the <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            Separator is forward slash "/".
            Directories end with "/" unless root directory.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntry.Name">
            <summary>
            Entry name in its parent context.
            
            All characters are legal, including control characters, except forward slash '/'. 
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntry.LastModified">
            <summary>
            Date time of last modification. In UTC time, if possible. If Unknown returns <see cref="F:System.DateTimeOffset.MinValue"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntry.LastAccess">
            <summary>
            Last access time of entry. If Unknown returns <see cref="F:System.DateTimeOffset.MinValue"/>.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileEntry">
            <summary>
            File entry
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileEntry.IsFile">
            <summary>
            Tests if entry represents a file.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileEntry.Length">
            <summary>
            File length. -1 if is length is unknown.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IDirectoryEntry">
            <summary>
            Directory entry that can be browsed for contents with <see cref="T:Lexical.FileSystem.IFileSystemBrowse"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDirectoryEntry.IsDirectory">
            <summary>
            Tests if entry represents a directory.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IDriveEntry">
            <summary>
            Drive or volume entry. 
            
            If drive class is browsable, then the implementation also implements <see cref="T:Lexical.FileSystem.IDirectoryEntry"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.IsDrive">
            <summary>
            Tests if entry represents a drive or volume.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.DriveType">
            <summary>
            Drive type.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.DriveFreeSpace">
            <summary>
            Free space, -1L if unknown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.DriveSize">
            <summary>
            Total size of drive or volume. -1L if unkown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.DriveLabel">
            <summary>
            Label, or null if unknown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDriveEntry.DriveFormat">
            <summary>
            File system format.
            
            Examples:
            <list type="bullet">
                <item>NTFS</item>
                <item>FAT32</item>
            </list>
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IMountEntry">
            <summary>
            Entry represents a mount point (decoration or virtual filesystem directory). 
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountEntry.IsMountPoint">
            <summary>
            Tests if directory represents a mount point.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountEntry.Mounts">
            <summary>
            (optional) Manually mounted filesystem(s).
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEntryDecoration">
            <summary>
            Optional interface that exposes decoree.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntryDecoration.Original">
            <summary>
            (Optional) Original entry that is being decorated.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEntryOptions">
            <summary>
            Entry specific filesystem capability options.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntryOptions.Options">
            <summary>
            (optional) Options that apply to this entry. The options here are equal or subset of the options in the parenting <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEntryFileAttributes">
            <summary>
            Entry file Attributes.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntryFileAttributes.HasFileAttributes">
            <summary>
            True, if has attached <see cref="T:System.IO.FileAttributes"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntryFileAttributes.FileAttributes">
            <summary>
            (optional) File attributes
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEntryPhysicalPath">
            <summary>
            Optional interface for entries that may have a physical file or directory path.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEntryPhysicalPath.PhysicalPath">
            <summary>
            (optional) Physical (OS) path to file or directory.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEvent">
            <summary>
            File entry event.
            
            See sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.ICreateEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IDeleteEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IChangeEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IRenameEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IErrorEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IStartEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IMountEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IUnmountEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.IEventDecoration"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEvent.Observer">
            <summary>
            The observer object that monitors the filesystem.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEvent.EventTime">
            <summary>
            The time the event occured, or approximation if not exactly known.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEvent.Path">
            <summary>
            (optional) Affected file or directory entry if applicable. 
            
            Path is relative to the filesystems's root.
            Directory separator is "/". Root path doesn't use separator.
            Example: "dir/file.ext"
            
            If event is <see cref="T:Lexical.FileSystem.IRenameEvent"/> the value is same as <see cref="P:Lexical.FileSystem.IRenameEvent.OldPath"/>.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IRenameEvent">
            <summary>
            File renamed event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IRenameEvent.OldPath">
            <summary>
            The affected file or directory.
            
            Path is relative to the <see cref="N:Lexical.FileSystem"/>'s root.
            
            Directory separator is "/". Root path doesn't use separator.
            
            Example: "dir/file.ext"
            
            This value is same as inherited <see cref="P:Lexical.FileSystem.IEvent.Path"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IRenameEvent.NewPath">
            <summary>
            The new file or directory path.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.ICreateEvent">
            <summary>
            File created event
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IDeleteEvent">
            <summary>
            File delete event
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IChangeEvent">
            <summary>
            File contents changed event.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IErrorEvent">
            <summary>
            Event for error with <see cref="T:Lexical.FileSystem.IFileSystem"/> or a file entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IErrorEvent.Error">
            <summary>
            Error as exception.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IStartEvent">
            <summary>
            The very first event when <see cref="M:Lexical.FileSystem.IFileSystemObserve.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)"/> is called.
            
            <see cref="T:Lexical.FileSystem.IStartEvent"/> must be handled in the thread that calls .Observe() 
            in the implementation of Observe() and before Observe() returns. It ignores .EventDispatcher property.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IMountEvent">
            <summary>
            The event when mountpoint is created or when assignments are changed when <see cref="M:Lexical.FileSystem.IFileSystemMount.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)"/> is called.
            
            Possible mounting <see cref="T:Lexical.FileSystem.ICreateEvent"/>s are sent afterwards.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountEvent.Assignments">
            <summary>(new) Assignment configuration at mountpoint</summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountEvent.Option">
            <summary>Mount option</summary>
        </member>
        <member name="T:Lexical.FileSystem.IUnmountEvent">
            <summary>
            The event when whole mountpoint is unmounted.
            
            Possible unmounting <see cref="T:Lexical.FileSystem.IDeleteEvent"/>s are sent afterwards.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEventDecoration">
            <summary>
            Signals that the event object decorates another event object.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IEventDecoration.Original">
            <summary>
            (optional) Original event that is decorated.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IEventDispatcher">
            <summary>
            Dispatches <see cref="T:Lexical.FileSystem.IEvent"/>s.
            
            Dispatcher implementation may capture unexpected exceptions from event handlers, or
            it may let them fly to the caller. 
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IEventDispatcher.DispatchEvents(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IEvent})">
            <summary>
            Dispatch <paramref name="events"/> to observers.
            
            If it recommended that the implementation enumerates <paramref name="events"/>, as this allows the caller to pass on heavy enumeration operations.
            </summary>
            <param name="events">(optional) Events</param>
            <exception cref="T:System.Exception">Any exception from observer may be captured or passed to caller</exception>
        </member>
        <member name="M:Lexical.FileSystem.IEventDispatcher.DispatchEvent(Lexical.FileSystem.IEvent)">
            <summary>
            Dispatch single <paramref name="event"/> to observers.
            </summary>
            <param name="event">(optional) events</param>
            <exception cref="T:System.Exception">Any exception from observer may be captured or passed to caller</exception>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystem">
            <summary>
            Root interface for file system interfaces. 
            
            See sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.IFileSystemOpen"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemCreateDirectory"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemBrowse"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemDelete"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemMove"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemObserve"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemMount"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemFileAttribute"/></item>
                <item><see cref="T:Lexical.FileSystem.IFileSystemDisposable"/></item>
            </list>
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemDisposable">
            <summary>
            Signals that the filesystem is also disposable.
            
            Used when returning filesystem from methods to signal disposability.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IBrowseOption">
            <summary>File system options for browse.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IBrowseOption.CanBrowse">
            <summary>Has Browse capability.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IBrowseOption.CanGetEntry">
            <summary>Has GetEntry capability.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemBrowse">
            <summary>
            File system that can browse directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemBrowse.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for child entries.
            
            <paramref name="path"/> should end with directory separator character '/', for example "mydir/".
            </summary>
            <param name="path">path to a directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>
                Returns a snapshot of file and directory entries.
                Note, that the returned array be internally cached by the implementation, and therefore the caller must not modify the array.
            </returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemBrowse.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemBrowseAsync">
            <summary>
            File system that can browse directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemBrowseAsync.BrowseAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for child entries.
            
            <paramref name="path"/> should end with directory separator character '/', for example "mydir/".
            </summary>
            <param name="path">path to a directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>
                Returns a snapshot of file and directory entries.
                Note, that the returned array be internally cached by the implementation, and therefore the caller must not modify the array.
            </returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemBrowseAsync.GetEntryAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IDirectoryContent">
            <summary>
            Browse result. Result is a snapshot of entries. The contents are immutable and reflect the contents at the time of browsing.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDirectoryContent.FileSystem">
            <summary>
            The filesystem where the browse was issued.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDirectoryContent.Path">
            <summary>
            The browsed path at <see cref="P:Lexical.FileSystem.IDirectoryContent.FileSystem"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IDirectoryContent.Exists">
            <summary>
            <see cref="P:Lexical.FileSystem.IDirectoryContent.Path"/> exists.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.ICreateDirectoryOption">
            <summary>File system option for creating directories.</summary>
        </member>
        <member name="P:Lexical.FileSystem.ICreateDirectoryOption.CanCreateDirectory">
            <summary>Has CreateDirectory capability.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemCreateDirectory">
            <summary>
            File system that can create directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemCreateDirectory.CreateDirectory(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            <paramref name="path"/> should end with directory separator character '/'.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemCreateDirectoryAsync">
            <summary>
            File system that can create directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemCreateDirectoryAsync.CreateDirectoryAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            <paramref name="path"/> should end with directory separator character '/'.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IDeleteOption">
            <summary>File system option for deleting files and directories.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IDeleteOption.CanDelete">
            <summary>Has Delete capability.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemDelete">
            <summary>
            File system that can delete files and directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemDelete.Delete(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="path"/> is directory, then it should end with directory separator character '/', for example "dir/".
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemDeleteAsync">
            <summary>
            File system that can delete files and directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemDeleteAsync.DeleteAsync(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="path"/> is directory, then it should end with directory separator character '/', for example "dir/".
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileAttributeOption">
            <summary>File system options for browse.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileAttributeOption.CanSetFileAttribute">
            <summary>Has SetFileAttribute capability.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemFileAttribute">
            <summary>
            File system that set file attribute.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemFileAttribute.SetFileAttribute(System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemFileAttributeAsync">
            <summary>
            File system that set file attribute.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemFileAttributeAsync.SetFileAttributeAsync(System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:Lexical.FileSystem.IMountOption">
            <summary>File system option for mount capabilities. Used with <see cref="T:Lexical.FileSystem.IFileSystemMount"/>.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountOption.CanMount">
            <summary>Can filesystem mount other filesystems.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountOption.CanUnmount">
            <summary>Is filesystem allowed to unmount a mount.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IMountOption.CanListMountPoints">
            <summary>Is filesystem allowed to list mountpoints.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemMount">
            <summary>
            FileSystem that can mount other filesystems into its directory tree.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMount.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="path"></param>
            <param name="mounts">(optional) filesystem and option infos</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMount.Unmount(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            If there is an open stream to previously mounted filesystem, that the file is unlinked, but stream remains open.
            If there are observers monitoring <paramref name="path"/> in the parent filesystem, then the unmounted files are notified as being deleted.
            </summary>
            <param name="path"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMount.ListMountPoints(Lexical.FileSystem.IOption)">
            <summary>
            List all mounts.
            </summary>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemAssignmentFlags">
            <summary>Mount assignemnt related info <see cref="T:Lexical.FileSystem.FileSystemAssignment"/>.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.None">
            <summary>No flags</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.Mounted">
            <summary>Signals that filesystem was manually mounted with <see cref="M:Lexical.FileSystem.IFileSystemMount.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)"/>.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.AutoMounted">
            <summary>Signals that filesystem was automatically mounted based on <see cref="T:Lexical.FileSystem.IAutoMountOption"/> options.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.AutoUnmount">
            <summary>Filesystem is to be automatically unmounted by timer when it hasn't been used in a configured time.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.Package">
            <summary>Mount represents a package file, such as .zip.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemAssignmentFlags.Decoration">
            <summary>Signaled as decoration assignment</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemMountAsync">
            <summary>
            FileSystem that can mount other filesystems into its directory tree.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMountAsync.MountAsync(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Mounts zero, one or many <see cref="T:Lexical.FileSystem.IFileSystem"/> with optional <see cref="T:Lexical.FileSystem.IOption"/> in the parent filesystem.
            
            If no mounts are provided, then creates empty virtual directory.
            If one mount is provided, then mounts that to parent filesystem, with possible mount option.
            If multiple mounts are provided, then mounts a composition of all the filesystem, with the precedence of the order in the provided array.
            
            If previous mounts exist at the <paramref name="path"/>, then replaces them with new configuration.
            
            If parent filesystem had observers monitoring the <paramref name="path"/>, then observers are notified with new emerged files from the mounted filesystems.
            
            The <paramref name="path"/> parameter must end with directory separator character '/', unless root directory "" is mounted.
            
            If there is an open stream to a mounted filesystem, then the file is unlinked from the parent filesystem, but stream maintains open.
            </summary>
            <param name="path"></param>
            <param name="mounts">(optional) filesystem and option infos</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMountAsync.UnmountAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            If there is an open stream to previously mounted filesystem, that the file is unlinked, but stream remains open.
            If there are observers monitoring <paramref name="path"/> in the parent filesystem, then the unmounted files are notified as being deleted.
            </summary>
            <param name="path"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMountAsync.ListMountPointsAsync(Lexical.FileSystem.IOption)">
            <summary>
            List all mounts.
            </summary>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="T:Lexical.FileSystem.IAutoMountOption">
            <summary>Option for auto-mounted packages.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IAutoMountOption.AutoMounters">
            <summary>Package loaders that can mount package files, such as .zip.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IMoveOption">
            <summary>File system option for move/rename.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IMoveOption.CanMove">
            <summary>Can Move files within same volume.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemMove">
            <summary>
            File system that can move/rename files and directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMove.Move(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory. 
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemMoveAsync">
            <summary>
            File system that can move/rename files and directories.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemMoveAsync.MoveAsync(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory. 
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IObserveOption">
            <summary>File system option for observe.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IObserveOption.CanObserve">
            <summary>Has Observe capability.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemObserve">
            <summary>
            File system that observe file and directory changes.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemObserve.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a directory. 
            
            The <paramref name="filter"/> determines the file pattern to observe.
             "*" Matches to any sequence characters within one folder.
             "**" Matches to any sequence characters including directory levels '/'.
             "?" Matches to one and exactly one character.
            
            Examples:
              <list type="bullet">
                <item>"**" is any file in any directory.</item>
                <item>"**/file.txt", to monitor "file.txt" in any subdirectory (excluding root due to missing "/")</item>
                <item>"*" is any set of characters file in one directory. For example "mydir/somefile*.txt"</item>
                <item>"", to monitor changes to the root directory itself, but not its files</item>
                <item>"dir", to monitor the dir itself, but not its files</item>
                <item>"dir/", to monitor the dir itself, but not its files</item>
                <item>"dir/file", to monitor one file "file"</item>
                <item>"dir/*", to monitor files in a dir but not subdirectories</item>
                <item>"dir/**", to monitor files in a dir and its subdirectories</item>
              </list>
            
            The implementation sends the reference to the observer handle in a <see cref="T:Lexical.FileSystem.IStartEvent"/> event before this method returns to caller.
            </summary>
            <param name="filter">file filter as glob pattern. </param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher to use to dispatch events to this obawecwe</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>handle to the observer, dispose to cancel the observe</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemObserver">
            <summary>
            Observer information.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileSystemObserver.FileSystem">
            <summary>
            The file system where the observer was attached.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileSystemObserver.Filter">
            <summary>
            File filter as glob pattern.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileSystemObserver.Observer">
            <summary>
            Callback.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileSystemObserver.State">
            <summary>
            State object that was attached at construction.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IFileSystemObserver.Dispatcher">
            <summary>
            (optional) Event dispatcher.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemObserveAsync">
            <summary>
            File system that observe file and directory changes.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemObserveAsync.ObserveAsync(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a directory. 
            
            The <paramref name="filter"/> determines the file pattern to observe.
             "*" Matches to any sequence characters within one folder.
             "**" Matches to any sequence characters including directory levels '/'.
             "?" Matches to one and exactly one character.
            
            Examples:
              <list type="bullet">
                <item>"**" is any file in any directory.</item>
                <item>"**/file.txt", to monitor "file.txt" in any subdirectory (excluding root due to missing "/")</item>
                <item>"*" is any set of characters file in one directory. For example "mydir/somefile*.txt"</item>
                <item>"", to monitor changes to the root directory itself, but not its files</item>
                <item>"dir", to monitor the dir itself, but not its files</item>
                <item>"dir/", to monitor the dir itself, but not its files</item>
                <item>"dir/file", to monitor one file "file"</item>
                <item>"dir/*", to monitor files in a dir but not subdirectories</item>
                <item>"dir/**", to monitor files in a dir and its subdirectories</item>
              </list>
            
            The implementation sends the reference to the observer handle in a <see cref="T:Lexical.FileSystem.IStartEvent"/> event before this method returns to caller.
            </summary>
            <param name="filter">file filter as glob pattern. </param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher to use to dispatch events to this obawecwe</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>handle to the observer, dispose to cancel the observe</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IOpenOption">
            <summary>File system options for open, create, read and write files.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IOpenOption.CanOpen">
            <summary>Can open file</summary>
        </member>
        <member name="P:Lexical.FileSystem.IOpenOption.CanRead">
            <summary>Can open file for reading(</summary>
        </member>
        <member name="P:Lexical.FileSystem.IOpenOption.CanWrite">
            <summary>Can open file for writing.</summary>
        </member>
        <member name="P:Lexical.FileSystem.IOpenOption.CanCreateFile">
            <summary>Can open and create file.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemOpen">
            <summary>
            File system that can open files for reading and writing. 
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemOpen.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="T:Lexical.FileSystem.IFileSystemOpenAsync">
            <summary>
            File system that can open files for reading and writing. 
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IFileSystemOpenAsync.OpenAsync(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternRegex">
            <summary>
            Glob pattern uses the following notation:
              "*" matches to string of characters within the same directory.
              "?" matches to any character except directory separator.
              "**" matches to any characters, including directory separators.
              
            For example: "**.zip/**.dll" 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegex.Pattern">
            <summary>The glob pattern as a string.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegex.DirectorySeparatorCharacters">
            <summary>Directory separator characters, e.g. "/".</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegex.#ctor(System.String)">
            <summary>
            Create glob pattern.
            </summary>
            <param name="globPattern"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegex.#ctor(System.String,System.String)">
            <summary>
            Create glob pattern.
            </summary>
            <param name="globPattern"></param>
            <param name="directorySeparatorCharacters"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegex.#ctor(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Create glob pattern with regexp options.
            </summary>
            <param name="globPattern"></param>
            <param name="directorySeparatorCharacters"></param>
            <param name="options"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegex.IsGlobPattern(System.String)">
            <summary>
            Analyses whether <paramref name="patternText"/> is a glob-pattern.
            </summary>
            <param name="patternText"></param>
            <returns>true if contains characters '?' or '*'</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternRegexFactory">
            <summary>
            Glob pattern factory that converts glob pattern string into regular expression.
            
            Glob pattern uses the following notation:
              "*" matches to string of characters within the same directory.
              "?" matches to any character except directory separator.
              "**" matches to any characters, including directory separators.
              
            For example: "**/*.zip/**.dll" 
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.GlobPatternRegexFactory.Slash">
            <summary>
            Singleton instance that assumes "/" is the directory separator.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.GlobPatternRegexFactory.Backslash">
            <summary>
            Singleton instance that assumes "\" is the directory separator.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.GlobPatternRegexFactory.SlashAndBackslash">
            <summary>
            Singleton instance that assumes that both "/" and "\" are used as directory separators.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegexFactory.Create(System.String)">
            <summary>
            Get or create GlobPatternFactory
            </summary>
            <param name="directorySeparatorCharacters">separator characters, e.g. "/\\"</param>
            <returns>glob pattern factory</returns>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.GlobPattern">
            <summary>
            Pattern that searches for "**", "*" and "?" characters
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.DirectorySeparatorChars">
            <summary>
            Parameters on how this directory is configured.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.twoStarPattern">
            <summary>
            Replace strings for each group.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.oneStarPattern">
            <summary>
            Replace strings for each group.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.questionMarkPattern">
            <summary>
            Replace strings for each group.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.matchEvaluator">
            <summary>
            Delegate used in Replace.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternRegexFactory.nonglobtextReplacer">
            <summary>
            Replacer for text parts that are not **, *, or ?.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegexFactory.#ctor(System.String,System.Text.RegularExpressions.MatchEvaluator)">
            <summary>
            Create new glob pattern.
            </summary>
            <param name="directorySeparatorChars">directory separtor characters, for example "/\\"</param>
            <param name="nonglobtextReplacer"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegexFactory.CreateRegexText(System.String)">
            <summary>
            Create glob pattern as regular expression text.
            </summary>
            <param name="globPattern"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegexFactory.CreateRegex(System.String)">
            <summary>
            Create glob pattern as compiled regular expression instance.
            </summary>
            <param name="globPattern"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternRegexFactory.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.PatternSet">
            <summary>
            A builder where multiple patterns are added and then united into one unifying pattern.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PatternSet.patterns">
            <summary>
            Regex patterns in string format. These will all be compiled into one pattern.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PatternSet.regex_patterns">
            <summary>
            Regex based patterns.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PatternSet.matcherFunc">
            <summary>
            A cache for matcher function.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.PatternSet.MatcherFunc">
            <summary>
            A function that matches all the added patterns.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PatternSet.scanDepth">
            <summary>
            Required scan depth.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PatternSet.BuildMatcherFunc">
            <summary>
            Build a function that matches all the wildcards and regular expressions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PatternSet.AddWildcard(System.String,System.Int32)">
            <summary>
            Add wildcard pattern, for example "*.dll"
            </summary>
            <param name="wildcard"></param>
            <param name="scanDepth">required scan depth</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PatternSet.AddGlobPattern(System.String,System.Int32,System.String)">
            <summary>
            Add glob pattern, for example "**.zip/**.dll"
            </summary>
            <param name="globPattern"></param>
            <param name="directorySeparatorChars"></param>
            <param name="scanDepth">required scan depth</param>
            <returns>this</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PatternSet.AddRegex(System.String,System.Int32)">
            <summary>
            Add regex pattern.
            </summary>
            <param name="regex_pattern"></param>
            <param name="scanDepth">required scan depth</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PatternSet.AddRegex(System.Text.RegularExpressions.Regex,System.Int32)">
            <summary>
            Add regex object.
            </summary>
            <param name="regex_pattern"></param>
            <param name="scanDepth">required scan depth</param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructList1`1">
            <summary>
            A list where the first 1 element(s) are stack allocated, and rest are allocated from heap when needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList1`1.StackCount">
            <summary>
            The number of elements that are stack allocated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList1`1.count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList1`1._0">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList1`1.rest">
            <summary>
            Elements after <see cref="F:Lexical.FileSystem.Internal.StructList1`1.StackCount"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList1`1.elementComparer">
            <summary>
            Element comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct lazy list.
            </summary>
            <param name="elementComparer"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList1`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList1`1.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList1`1.Count">
            <summary>
            Number of elements in the list
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList1`1.IsReadOnly">
            <summary>
            Is list readonly
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Add(`0)">
            <summary>
            Adds an item to the StructList1`1.
            </summary>
            <param name="item">The object to add to the StructList1`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList1`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.AddIfNew(`0)">
            <summary>
            Adds an item to the StructList1`1, if the item isn't already in the list.
            </summary>
            <param name="item">The object to add to the StructList1`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList1`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the StructList1`1.
            </summary>
            <param name="item">The object to remove from the StructList1`1.</param>
            <returns>true if item was successfully removed from the StructList1`1; otherwise, false. This method also returns false if item is not found in the original StructList1`1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.RemoveAt(System.Int32)">
            <summary>
            Removes the StructList1`1 item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList1`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Dequeue">
            <summary>
            Removes and returns the element at the end of the list.
            </summary>
            <returns>the last element</returns>
            <exception cref="T:System.InvalidOperationException">If list is empty</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Clear">
            <summary>
            Removes all items from the StructList1`1.
            </summary>
            <exception cref="T:System.NotSupportedException">The StructList1`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Contains(`0)">
            <summary>
            Determines whether the StructList1`1 contains a specific value.
            </summary>
            <param name="item">The object to locate in the StructList1`1.</param>
            <returns>true if item is found in the StructList1`1; otherwise, false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the StructList1`1.
            </summary>
            <param name="item">The object to locate in the StructList1`1.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the StructList1`1 at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert into the StructList1`1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList1`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the StructList1`1 to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements copied from StructList1`1. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source StructList1`1 is greater than the available space from arrayIndex to the end of the destination array.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.ToArray">
            <summary>
            Create array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.ToReverseArray">
            <summary>
            Create array with elements reversed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList1`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructList2`1">
            <summary>
            A list where the first 2 element(s) are stack allocated, and rest are allocated from heap when needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1.StackCount">
            <summary>
            The number of elements that are stack allocated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1.count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1._0">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1._1">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1.rest">
            <summary>
            Elements after <see cref="F:Lexical.FileSystem.Internal.StructList2`1.StackCount"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList2`1.elementComparer">
            <summary>
            Element comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct lazy list.
            </summary>
            <param name="elementComparer"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList2`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList2`1.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList2`1.Count">
            <summary>
            Number of elements in the list
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList2`1.IsReadOnly">
            <summary>
            Is list readonly
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Add(`0)">
            <summary>
            Adds an item to the StructList2`1.
            </summary>
            <param name="item">The object to add to the StructList2`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList2`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.AddIfNew(`0)">
            <summary>
            Adds an item to the StructList2`1, if the item isn't already in the list.
            </summary>
            <param name="item">The object to add to the StructList2`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList2`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the StructList2`1.
            </summary>
            <param name="item">The object to remove from the StructList2`1.</param>
            <returns>true if item was successfully removed from the StructList2`1; otherwise, false. This method also returns false if item is not found in the original StructList2`1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.RemoveAt(System.Int32)">
            <summary>
            Removes the StructList2`1 item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList2`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Dequeue">
            <summary>
            Removes and returns the element at the end of the list.
            </summary>
            <returns>the last element</returns>
            <exception cref="T:System.InvalidOperationException">If list is empty</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Clear">
            <summary>
            Removes all items from the StructList2`1.
            </summary>
            <exception cref="T:System.NotSupportedException">The StructList2`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Contains(`0)">
            <summary>
            Determines whether the StructList2`1 contains a specific value.
            </summary>
            <param name="item">The object to locate in the StructList2`1.</param>
            <returns>true if item is found in the StructList2`1; otherwise, false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the StructList2`1.
            </summary>
            <param name="item">The object to locate in the StructList2`1.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the StructList2`1 at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert into the StructList2`1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList2`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the StructList2`1 to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements copied from StructList2`1. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source StructList2`1 is greater than the available space from arrayIndex to the end of the destination array.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.ToArray">
            <summary>
            Create array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.ToReverseArray">
            <summary>
            Create array with elements reversed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList2`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructList4`1">
            <summary>
            A list where the first 4 element(s) are stack allocated, and rest are allocated from heap when needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1.StackCount">
            <summary>
            The number of elements that are stack allocated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1.count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1._0">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1._1">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1._2">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1._3">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1.rest">
            <summary>
            Elements after <see cref="F:Lexical.FileSystem.Internal.StructList4`1.StackCount"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList4`1.elementComparer">
            <summary>
            Element comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct lazy list.
            </summary>
            <param name="elementComparer"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList4`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList4`1.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList4`1.Count">
            <summary>
            Number of elements in the list
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList4`1.IsReadOnly">
            <summary>
            Is list readonly
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Add(`0)">
            <summary>
            Adds an item to the StructList4`1.
            </summary>
            <param name="item">The object to add to the StructList4`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList4`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.AddIfNew(`0)">
            <summary>
            Adds an item to the StructList4`1, if the item isn't already in the list.
            </summary>
            <param name="item">The object to add to the StructList4`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList4`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the StructList4`1.
            </summary>
            <param name="item">The object to remove from the StructList4`1.</param>
            <returns>true if item was successfully removed from the StructList4`1; otherwise, false. This method also returns false if item is not found in the original StructList4`1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.RemoveAt(System.Int32)">
            <summary>
            Removes the StructList4`1 item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList4`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Dequeue">
            <summary>
            Removes and returns the element at the end of the list.
            </summary>
            <returns>the last element</returns>
            <exception cref="T:System.InvalidOperationException">If list is empty</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Clear">
            <summary>
            Removes all items from the StructList4`1.
            </summary>
            <exception cref="T:System.NotSupportedException">The StructList4`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Contains(`0)">
            <summary>
            Determines whether the StructList4`1 contains a specific value.
            </summary>
            <param name="item">The object to locate in the StructList4`1.</param>
            <returns>true if item is found in the StructList4`1; otherwise, false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the StructList4`1.
            </summary>
            <param name="item">The object to locate in the StructList4`1.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the StructList4`1 at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert into the StructList4`1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList4`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the StructList4`1 to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements copied from StructList4`1. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source StructList4`1 is greater than the available space from arrayIndex to the end of the destination array.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.ToArray">
            <summary>
            Create array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.ToReverseArray">
            <summary>
            Create array with elements reversed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList4`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructList12`1">
            <summary>
            A list where the first 12 element(s) are stack allocated, and rest are allocated from heap when needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1.StackCount">
            <summary>
            The number of elements that are stack allocated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1.count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._0">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._1">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._2">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._3">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._4">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._5">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._6">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._7">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._8">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._9">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._10">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1._11">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1.rest">
            <summary>
            Elements after <see cref="F:Lexical.FileSystem.Internal.StructList12`1.StackCount"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList12`1.elementComparer">
            <summary>
            Element comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct lazy list.
            </summary>
            <param name="elementComparer"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList12`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList12`1.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList12`1.Count">
            <summary>
            Number of elements in the list
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList12`1.IsReadOnly">
            <summary>
            Is list readonly
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Add(`0)">
            <summary>
            Adds an item to the StructList12`1.
            </summary>
            <param name="item">The object to add to the StructList12`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList12`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.AddIfNew(`0)">
            <summary>
            Adds an item to the StructList12`1, if the item isn't already in the list.
            </summary>
            <param name="item">The object to add to the StructList12`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList12`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the StructList12`1.
            </summary>
            <param name="item">The object to remove from the StructList12`1.</param>
            <returns>true if item was successfully removed from the StructList12`1; otherwise, false. This method also returns false if item is not found in the original StructList12`1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.RemoveAt(System.Int32)">
            <summary>
            Removes the StructList12`1 item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList12`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Dequeue">
            <summary>
            Removes and returns the element at the end of the list.
            </summary>
            <returns>the last element</returns>
            <exception cref="T:System.InvalidOperationException">If list is empty</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Clear">
            <summary>
            Removes all items from the StructList12`1.
            </summary>
            <exception cref="T:System.NotSupportedException">The StructList12`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Contains(`0)">
            <summary>
            Determines whether the StructList12`1 contains a specific value.
            </summary>
            <param name="item">The object to locate in the StructList12`1.</param>
            <returns>true if item is found in the StructList12`1; otherwise, false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the StructList12`1.
            </summary>
            <param name="item">The object to locate in the StructList12`1.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the StructList12`1 at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert into the StructList12`1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList12`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the StructList12`1 to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements copied from StructList12`1. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source StructList12`1 is greater than the available space from arrayIndex to the end of the destination array.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.ToArray">
            <summary>
            Create array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.ToReverseArray">
            <summary>
            Create array with elements reversed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList12`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructList24`1">
            <summary>
            A list where the first 24 element(s) are stack allocated, and rest are allocated from heap when needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1.StackCount">
            <summary>
            The number of elements that are stack allocated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1.count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._0">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._1">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._2">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._3">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._4">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._5">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._6">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._7">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._8">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._9">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._10">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._11">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._12">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._13">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._14">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._15">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._16">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._17">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._18">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._19">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._20">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._21">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._22">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1._23">
            <summary>
            First elements
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1.rest">
            <summary>
            Elements after <see cref="F:Lexical.FileSystem.Internal.StructList24`1.StackCount"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StructList24`1.elementComparer">
            <summary>
            Element comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct lazy list.
            </summary>
            <param name="elementComparer"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList24`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList24`1.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList24`1.Count">
            <summary>
            Number of elements in the list
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StructList24`1.IsReadOnly">
            <summary>
            Is list readonly
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Add(`0)">
            <summary>
            Adds an item to the StructList24`1.
            </summary>
            <param name="item">The object to add to the StructList24`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList24`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.AddIfNew(`0)">
            <summary>
            Adds an item to the StructList24`1, if the item isn't already in the list.
            </summary>
            <param name="item">The object to add to the StructList24`1.</param>
            <exception cref="T:System.NotSupportedException">The StructList24`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the StructList24`1.
            </summary>
            <param name="item">The object to remove from the StructList24`1.</param>
            <returns>true if item was successfully removed from the StructList24`1; otherwise, false. This method also returns false if item is not found in the original StructList24`1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.RemoveAt(System.Int32)">
            <summary>
            Removes the StructList24`1 item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList24`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Dequeue">
            <summary>
            Removes and returns the element at the end of the list.
            </summary>
            <returns>the last element</returns>
            <exception cref="T:System.InvalidOperationException">If list is empty</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Clear">
            <summary>
            Removes all items from the StructList24`1.
            </summary>
            <exception cref="T:System.NotSupportedException">The StructList24`1 is read-only.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Contains(`0)">
            <summary>
            Determines whether the StructList24`1 contains a specific value.
            </summary>
            <param name="item">The object to locate in the StructList24`1.</param>
            <returns>true if item is found in the StructList24`1; otherwise, false.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the StructList24`1.
            </summary>
            <param name="item">The object to locate in the StructList24`1.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the StructList24`1 at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="item">The object to insert into the StructList24`1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the StructList24`1.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the StructList24`1 to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements copied from StructList24`1. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source StructList24`1 is greater than the available space from arrayIndex to the end of the destination array.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.ToArray">
            <summary>
            Create array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.ToReverseArray">
            <summary>
            Create array with elements reversed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructList24`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StructListSorter`2">
            <summary>
            Inplace sorter that is intended specifically for struct based lists, but works on any <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="List"></typeparam>
            <typeparam name="Element"></typeparam>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructListSorter`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
            Create sorter
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructListSorter`2.Reverse(`0@)">
            <summary>
            Reverse elements of a list
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructListSorter`2.Sort(`0@)">
            <summary>
            Sort elements of list
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructListSorter`2.QuickSort(`0@,System.Int32,System.Int32)">
            <summary>
            Sort elements of list
            </summary>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StructListSorter`2.QuickSortInverse(`0@,System.Int32,System.Int32)">
            <summary>
            Sort elements of list
            </summary>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="T:Lexical.FileSystem.IOption">
            <summary>
            Interface for filesystem options. 
            
            See sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.IAdaptableOption"/></item>
                <item><see cref="T:Lexical.FileSystem.ISubPathOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IPathInfo"/></item>
                <item><see cref="T:Lexical.FileSystem.IAutoMountOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IToken"/></item>
                <item><see cref="T:Lexical.FileSystem.IOpenOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IObserveOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IMoveOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IBrowseOption"/></item>
                <item><see cref="T:Lexical.FileSystem.ICreateDirectoryOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IDeleteOption"/></item>
                <item><see cref="T:Lexical.FileSystem.IMountOption"/></item>
            </list>
            
            The options properties must be immutable in the implementing classes.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IAdaptableOption">
            <summary>
            Interface for option classes that adapt to option types at runtime.
            Also enumerates supported <see cref="T:Lexical.FileSystem.IOption"/> option type interfaces.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IAdaptableOption.GetOption(System.Type)">
            <summary>
            Get option with type interface.
            </summary>
            <param name="optionInterfaceType">Subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>Option or null</returns>
        </member>
        <member name="T:Lexical.FileSystem.ISubPathOption">
            <summary>Option for mount path. Use with decorator.</summary>
        </member>
        <member name="P:Lexical.FileSystem.ISubPathOption.SubPath">
            <summary>Sub-path.</summary>
        </member>
        <member name="T:Lexical.FileSystem.IPathInfo">
            <summary>Path related options</summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathInfo.CaseSensitivity">
            <summary>Case sensitivity</summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathInfo.EmptyDirectoryName">
            <summary>Filesystem allows empty string "" directory names. The value of this property excludes the default empty "" root path.</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemCaseSensitivity">
            <summary>Knolwedge about path name case sensitivity</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemCaseSensitivity.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemCaseSensitivity.CaseSensitive">
            <summary>Path names are case-sensitive</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemCaseSensitivity.CaseInsensitive">
            <summary>Path names are case-insensitive</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemCaseSensitivity.Inconsistent">
            <summary>Some parts are sensitive, some insensitive</summary>
        </member>
        <member name="T:Lexical.FileSystem.IOptionOperation">
            <summary>
            <see cref="T:Lexical.FileSystem.IOption"/> interface type specific operations handling.
            
            See sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.IOptionUnionOperation"/></item>
                <item><see cref="T:Lexical.FileSystem.IOptionIntersectionOperation"/></item>
                <item><see cref="T:Lexical.FileSystem.IOptionFlattenOperation"/></item>
            </list>
            
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IOptionOperation.OptionType">
            <summary>
            The subinterface of <see cref="T:Lexical.FileSystem.IOption"/> that this class manages.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.IOptionUnionOperation">
            <summary>
            <see cref="T:Lexical.FileSystem.IOption"/> interface type specific operations handling.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IOptionUnionOperation.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Join two instances of the option type.
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.IOptionIntersectionOperation">
            <summary>
            <see cref="T:Lexical.FileSystem.IOption"/> interface type specific operations handling.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IOptionIntersectionOperation.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Join two instances of the option type.
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.IOptionFlattenOperation">
            <summary>
            <see cref="T:Lexical.FileSystem.IOption"/> interface type specific operations handling.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.IOptionFlattenOperation.Flatten(Lexical.FileSystem.IOption)">
            <summary>
            Creates more simplified instance of <paramref name="o"/>.
            May return a singleton.
            </summary>
            <param name="o"></param>
            <returns>Effectively same content than <paramref name="o"/>, but may be reference to a lighter object</returns>
        </member>
        <member name="T:Lexical.FileSystem.OperationsAttribute">
            <summary>
            Attribute for <see cref="T:Lexical.FileSystem.IOption"/> interfaces to expose a class that manages operations for that interface.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OperationsAttribute.OperationsClass">
            <summary>
            A class that implements <see cref="T:Lexical.FileSystem.IOptionOperation"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.OperationsAttribute.#ctor(System.Type)">
            <summary>
            Crate attribute that gives reference to a class that manages an operations for an option interface or class.
            </summary>
            <param name="operationsClass">A class that implements <see cref="T:Lexical.FileSystem.IOptionOperation"/>.</param>
        </member>
        <member name="T:Lexical.FileSystem.IToken">
            <summary>
            Abstract token that can be passed to filesystem implementations.
            Token is typically a session, a security token such as credential
            
            Token implementation must be immutable.
            
            See more specific subinterfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.ITokenObject"/></item>
                <item><see cref="T:Lexical.FileSystem.ITokenEnumerable"/></item>
                <item><see cref="T:Lexical.FileSystem.ITokenProvider"/></item>
            </list>
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.ITokenObject">
            <summary>
            A single token object.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ITokenObject.TokenObject">
            <summary>
            (optional) Token object
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ITokenObject.Key">
            <summary>
            (optional) Key type to identify token as. This is typically <see cref="P:System.Type.FullName"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ITokenObject.Patterns">
            <summary>
            (optional) Glob pattern filters for paths this token is offered to.
            If null, then this token is offered to every filesystem (same as "**").
            If empty array, then the token is not offered to any filesystem.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.ITokenProvider">
            <summary>
            Queryable token.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.ITokenProvider.TryGetToken(System.String,System.String,System.Object@)">
            <summary>
            Query for first token object at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.ITokenProvider.TryGetAllTokens(System.String,System.String,System.Object[]@)">
            <summary>
            Query for all token objects at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="T:Lexical.FileSystem.ITokenEnumerable">
            <summary>
            Object that contains multiple tokens. 
            
            If class that implements <see cref="T:Lexical.FileSystem.ITokenEnumerable"/>, also implements <see cref="T:Lexical.FileSystem.ITokenProvider"/>
            then it must provide only for the tokens that it can enumerate (either recursively or not).
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperation">
            <summary>
            A file operation.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.Session">
            <summary>The session where the op is ran in.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.CurrentState">
            <summary>Current state of the operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.Errors">
            <summary>Error events that occured involving this op</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.Children">
            <summary>Child operations</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.FileSystem">
            <summary>Target filesystem, if applicable for the operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.Path">
            <summary>Target path, if applicable for the operation.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.SrcFileSystem">
            <summary>Source filesystem, if applicable for the operation. Copy, move and transfer operation use this.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.SrcPath">
            <summary>Source path, if applicable for the operation. Copy, move and transfer operations use this.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.Progress">
            <summary>Current progress of operation in bytes. -1 if unknown.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.TotalLength">
            <summary>Total length of operation in bytes. -1 if unknown.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.OpPolicy">
            <summary>Operation overriding policy. If set to <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.Unset"/>, then uses policy from session.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.EffectivePolicy">
            <summary>
            Effective policy for the operation. 
            
            For source and destination file policies prioritizes the policy on the operation, then fallback to policy on session.
            For other flags uses union of the policy in operation and the policy on session.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperation.CanRollback">
            <summary>
            Is operation capable of rollback. Value may change after <see cref="M:Lexical.FileSystem.Operation.IOperation.Estimate"/> and <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.IOperation.Estimate">
            <summary>
            Estimate viability and size of the operation.
            
            Creates an action plan, and adds them to <see cref="P:Lexical.FileSystem.Operation.IOperation.Children"/>.
            
            May change <see cref="P:Lexical.FileSystem.Operation.IOperation.CanRollback"/> value to true from default false.
            
            If caller needs rollback capability, the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertCanRollback(Lexical.FileSystem.Operation.IOperation)"/> right after estimate.
            </summary>
            <exception cref="T:System.Exception">If operation is not viable</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)">
            <summary>
            Run the operation.
            
            Throws exception on unexpected error.
            
            The caller should test <see cref="P:Lexical.FileSystem.Operation.IOperation.CurrentState"/> to see how operation completed.
            <list type="bullet">
                <item>If canceltoken was canelled then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Cancelled"/>.</item>
                <item>If file already existed and policy has <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.SrcSkip"/> or <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip"/>, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Skipped"/>.</item>
                <item>If unexpected error was thrown, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Error"/>.</item>
                <item>If operation was ran to end, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Completed"/>.</item>
            </list>
            Or the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertSuccessful(Lexical.FileSystem.Operation.IOperation)"/> to assert that operation ran into successful state.
            </summary>
            <param name="rollbackOnError"></param>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.IOperation.CreateRollback">
            <summary>
            Create rollback operation that reverts already executed operations.
            </summary>
            <returns>null, if rollback could not be created</returns>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationExtensions">
            <summary><see cref="T:Lexical.FileSystem.Operation.IOperation"/> Extension methods.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationExtensions.AssertCanRollback(Lexical.FileSystem.Operation.IOperation)">
            <summary>
            Asserts that <see cref="P:Lexical.FileSystem.Operation.IOperation.CanRollback"/> is true.
            </summary>
            <param name="op"></param>
            <returns>this</returns>
            <exception cref="T:System.Exception">If <see cref="P:Lexical.FileSystem.Operation.IOperation.CanRollback"/> is false.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationExtensions.AssertSuccessful(Lexical.FileSystem.Operation.IOperation)">
            <summary>
            Asserts that <see cref="P:Lexical.FileSystem.Operation.IOperation.CurrentState"/> is either <see cref="F:Lexical.FileSystem.Operation.OperationState.Completed"/> or <see cref="F:Lexical.FileSystem.Operation.OperationState.Skipped"/>.
            </summary>
            <param name="op"></param>
            <returns>this</returns>
            <exception cref="T:System.OperationCanceledException">If state is <see cref="F:Lexical.FileSystem.Operation.OperationState.Cancelled"/></exception>
            <exception cref="T:System.AggregateException">If state is <see cref="F:Lexical.FileSystem.Operation.OperationState.Error"/></exception>
            <exception cref="T:System.Exception">If state is unexpected</exception>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperationEvent">
            <summary>
            File operation event.
            
            See sub-interfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.Operation.IOperationStateEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.Operation.IOperationErrorEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.Operation.IOperationProgressEvent"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationEvent.Op">
            <summary>(optional) Involved operation</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperationStateEvent">
            <summary>State changed event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationStateEvent.OpState">
            <summary>New state</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperationErrorEvent">
            <summary>Error state event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationErrorEvent.Exception">
            <summary>Error</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperationProgressEvent">
            <summary>Progress event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationProgressEvent.Length">
            <summary>Current position of operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationProgressEvent.TotalLength">
            <summary>Total length of operation</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.IOperationSession">
            <summary>File operation session</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.CancelSrc">
            <summary>Shared cancellation token</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.Policy">
            <summary>Operation policies</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.Events">
            <summary>Accumulated events</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.Ops">
            <summary>Operations executed in this session</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.HasObservers">
            <summary>Tests if there are observers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.BlockPool">
            <summary>Pool that allocates byte buffers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.ProgressInterval">
            <summary>Interval of bytes interval to report progress on copying files.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.IOperationSession.Option">
            <summary>(optional) Option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.IOperationSession.LogAndDispatchEvent(Lexical.FileSystem.Operation.IOperationEvent)">
            <summary>Add event to session log and dispatch it. <see cref="T:Lexical.FileSystem.Operation.IOperationProgressEvent"/> events are not added to event log.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.IOperationSession.DispatchEvent(Lexical.FileSystem.Operation.IOperationEvent)">
            <summary>Dispatch event to observers (in current thread)</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationSessionExtensions">
            <summary>Operation sesssion extensions</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSessionExtensions.SetPolicy(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Set new policy</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSessionExtensions.SetProgressInterval(Lexical.FileSystem.Operation.IOperationSession,System.Int64)">
            <summary>Set new policy</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSessionExtensions.SetCancellationSource(Lexical.FileSystem.Operation.IOperationSession,System.Threading.CancellationTokenSource)">
            <summary>Set new policy</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationPolicy">
            <summary>File operation policy</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.Unset">
            <summary>Policy is not set. If used in FileOperation, then inherits policy from its session.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.SrcUnset">
            <summary>Source policy is not set.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.SrcThrow">
            <summary>Throw <see cref="T:System.IO.FileNotFoundException"/> or <see cref="T:System.IO.DirectoryNotFoundException"/> if source files or directories are not found.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.SrcSkip">
            <summary>If source files or directories are not found, then operation is skipped</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.SrcMask">
            <summary>Source policy mask</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DstUnset">
            <summary>Destination policy is not set.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DstThrow">
            <summary>If destination file already exists (or doesn't exist on delete), throw <see cref="T:Lexical.FileSystem.FileSystemExceptionFileExists"/> or <see cref="T:Lexical.FileSystem.FileSystemExceptionDirectoryExists"/>.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip">
            <summary>If destination file already exists, skip the operation on them.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DstOverwrite">
            <summary>If destination file already exists, overwrite it.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DstMask">
            <summary>Destination policy mask</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.EstimateUnset">
            <summary>No estimate flags</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.EstimateOnRun">
            <summary>Estimate on Run(). Public method Estimate() does nothing.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.ReEstimateOnRun">
            <summary>Re-estimate on Run(). Runs on Estimate() and Run().</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.EstimateMask">
            <summary>Estimate flags mask</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.RollbackUnset">
            <summary>No rollback flags</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.RollbackMask">
            <summary>Rollback flags mask</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.CancelOnError">
            <summary>If one operation fails, signals cancel on <see cref="!:FileOperationSession.CancelSrc"/> cancel token source.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.OmitMountedPackages">
            <summary>Policy whether to omit directories that are mounted packages, such as .zip.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.BatchContinueOnError">
            <summary>Batch operation continues on child op error. Throws <see cref="T:System.AggregateException"/> on errors, but only after all child ops have been ran.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.SuppressException">
            <summary>Suppress exception in Estimate() and Run().</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.LogEvents">
            <summary>Log events to session.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.DispatchEvents">
            <summary>Dispatch events to subscribers.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.FlagsMask">
            <summary>Mask for flags</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationPolicy.Default">
            <summary>Default policy</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationState">
            <summary>Operation State</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Initialized">
            <summary>Operation has been initialized</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Estimating">
            <summary>Operation size and viability are being estimated</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Estimated">
            <summary>Operation size and viability have been estimated</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Running">
            <summary>Started and running</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Skipped">
            <summary>Action skipped</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Completed">
            <summary>Run completed ok</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Cancelled">
            <summary>Run interrupted with cancellation token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationState.Error">
            <summary>Run failed</summary>
        </member>
        <member name="T:Lexical.FileSystem.Option">
            <summary>
            Facade for <see cref="T:Lexical.FileSystem.IOption"/> static values.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Join(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Join <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Join(Lexical.FileSystem.IOption[])">
            <summary>Join <paramref name="options"/>, takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Join(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IOption})">
            <summary>Join <paramref name="options"/>, takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.OptionJoin(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Join <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Union(Lexical.FileSystem.IOption[])">
            <summary>Union of <paramref name="options"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Union(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IOption})">
            <summary>Union of <paramref name="options"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.OptionUnion(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Intersection(Lexical.FileSystem.IOption[])">
            <summary>Intersection of <paramref name="options"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Intersection(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IOption})">
            <summary>Intersection of <paramref name="options"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.OptionIntersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="option1"/> and <paramref name="option2"/>. Takes first instance of each option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.ReadOnly">
            <summary>Read-only operations allowed, deny modification and write operations</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoOptions">
            <summary>No options</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Path(Lexical.FileSystem.FileSystemCaseSensitivity,System.Boolean)">
            <summary>Path options.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.Observe">
            <summary>Observe is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoObserve">
            <summary>Observe is not allowed</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.Open(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Open options</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.OpenReadWriteCreate">
            <summary>Open, Read, Write, Create</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.OpenReadWrite">
            <summary>Open, Read, Write</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.OpenRead">
            <summary>Open, Read</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoOpen">
            <summary>No access</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.Mount">
            <summary>Mount is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoMount">
            <summary>Mount is not allowed</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.Move">
            <summary>Move and rename is allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoMove">
            <summary>Move and rename not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.Delete">
            <summary>Delete allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoDelete">
            <summary>Delete not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.CreateDirectory">
            <summary>CreateDirectory allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoCreateDirectory">
            <summary>CreateDirectory not allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.Browse">
            <summary>Browse allowed.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoBrowse">
            <summary>Browse not allowed.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Option.SubPath(System.String)">
            <summary>Create option for sub-path. Used with decorator and virtual filesystem mount option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Option.NoSubPath">
            <summary>No mount path.</summary>
        </member>
        <member name="T:Lexical.FileSystem.NoOption">
            <summary>No options of <see cref="T:Lexical.FileSystem.IOption"/>.</summary>
        </member>
        <member name="F:Lexical.FileSystem.NoOption.instance">
            <summary>No options</summary>
        </member>
        <member name="P:Lexical.FileSystem.NoOption.Instance">
            <summary>No options</summary>
        </member>
        <member name="M:Lexical.FileSystem.NoOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.ReadOnlyOption">
            <summary>
            FileSystem option that denies write and modification operations.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.Instance">
            <summary>Read-only operations allowed, deny modification and write operations</summary>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanMount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanUnmount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanListMountPoints">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.ReadOnlyOption.CanObserve">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.ReadOnlyOption.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.OptionComposition">
            <summary>
            Implementations to <see cref="T:Lexical.FileSystem.IOption"/>.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.OptionComposition.Op">
            <summary>
            Join operation
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OptionComposition.Op.Union">
            <summary>
            Uses union of option instances
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OptionComposition.Op.Intersection">
            <summary>
            Uses intersection of option instances
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OptionComposition.Op.First">
            <summary>
            Uses first option instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OptionComposition.Op.Last">
            <summary>
            Uses last option instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.OptionComposition.byType">
            <summary>
            Options sorted by type.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.#ctor(Lexical.FileSystem.OptionComposition.Op,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Create composition of filesystem options.
            </summary>
            <param name="op">Join operation of same option intefaces</param>
            <param name="option1">option to join</param>
            <param name="option2">option to join</param>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.#ctor(Lexical.FileSystem.OptionComposition.Op,System.Collections.Generic.IEnumerable{Lexical.FileSystem.IOption},System.Type[])">
            <summary>
            Create composition of filesystem options.
            </summary>
            <param name="op">Join operation of same option intefaces</param>
            <param name="options">options to compose</param>
            <param name="interfaceTypesToExclude">(optional)</param>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.#ctor(Lexical.FileSystem.OptionComposition.Op,Lexical.FileSystem.IOption[])">
            <summary>
            Create composition of filesystem options.
            </summary>
            <param name="op">Join operation of same option intefaces</param>
            <param name="options">options to compose</param>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.Add(Lexical.FileSystem.OptionComposition.Op,System.Type,Lexical.FileSystem.IOption)">
            <summary>
            Add option to the composition.
            </summary>
            <param name="op">Join method</param>
            <param name="type">Interface type to add as</param>
            <param name="option">Option instance to add to composition</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported"></exception>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.Flatten">
            <summary>
            Remove references of unknown classes.
            Sometimes options are instances of <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            Those are replaced with lighter option instances.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.OptionComposition.GetOption(System.Type)">
            <summary>
            Get option by type.
            </summary>
            <param name="optionInterfaceType"></param>
            <returns>option or null</returns>
        </member>
        <member name="T:Lexical.FileSystem.OptionExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IOption"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.OptionExtensions.AsOption``1(Lexical.FileSystem.IOption)">
            <summary>
            Get option as <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="option"></param>
            <returns>Option casted as <typeparamref name="T"/> or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionExtensions.TryAsOption``1(Lexical.FileSystem.IOption,``0@)">
            <summary>
            Get option as <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="option"></param>
            <param name="casted"></param>
            <returns>true if option casted as <typeparamref name="T"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionExtensions.SubPath(Lexical.FileSystem.IOption)">
            <summary>
            Get sub-path option.
            <param name="filesystemOption"></param>
            </summary>
            <returns>mount path or null</returns>
        </member>
        <member name="T:Lexical.FileSystem.OptionOperationExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IOptionOperation"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.OptionFlattenAs(Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Flatten <paramref name="option"/> as <paramref name="optionType"/>.
            </summary>
            <param name="option"></param>
            <param name="optionType">option interface type, a subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>Either <paramref name="option"/> or flattened version as <paramref name="optionType"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.OptionUnionAs(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Take union of <paramref name="option"/> and <paramref name="anotherOption"/> as <paramref name="optionType"/>.
            </summary>
            <param name="option"></param>
            <param name="anotherOption"></param>
            <param name="optionType">option interface type, a subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>flattened instance of <paramref name="optionType"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.OptionIntersectionAs(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Take intersection of <paramref name="option"/> and <paramref name="anotherOption"/> as <paramref name="optionType"/>.
            </summary>
            <param name="option"></param>
            <param name="anotherOption"></param>
            <param name="optionType">option interface type, a subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>flattened instance of <paramref name="optionType"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.OperationTypes(Lexical.FileSystem.IOption)">
            <summary>
            Enumerate all the supported <see cref="T:Lexical.FileSystem.IOption"/> Types.
            </summary>
            <param name="option"></param>
            <returns>types</returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.GetOperation(Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Get first operation instance for <paramref name="option"/>.
            </summary>
            <param name="option"></param>
            <param name="optionType">option interface type, a subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>operation instance or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.OptionOperationExtensions.Operation``1(Lexical.FileSystem.IOption,System.Type)">
            <summary>
            Get operation instance that implements operation <typeparamref name="T"/> for option interface type <paramref name="optionType"/>.
            </summary>
            <param name="option"></param>
            <param name="optionType">option interface type, a subtype of <see cref="T:Lexical.FileSystem.IOption"/></param>
            <returns>operation instance</returns>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionOptionOperationNotSupported">If operation is not supported.</exception>
        </member>
        <member name="T:Lexical.FileSystem.PathInfoExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IPathInfo"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.PathInfoExtensions.CaseSensitivity(Lexical.FileSystem.IOption)">
            <summary>
            Get case sensitivity.
            <param name="filesystemOption"></param>
            </summary>
            <returns>mount path or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.PathInfoExtensions.EmptyDirectoryName(Lexical.FileSystem.IOption)">
            <summary>
            Get option for Filesystem allows empty string "" directory names.
            <param name="filesystemOption"></param>
            </summary>
            <returns>mount path or null</returns>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemOptionOperationPath">
            <summary><see cref="T:Lexical.FileSystem.IPathInfo"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemOptionOperationPath.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOptionOperationPath.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOptionOperationPath.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOptionOperationPath.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemOptionPath">
            <summary>Path related options</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemOptionPath.CaseSensitivity">
            <summary>Case sensitivity</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemOptionPath.EmptyDirectoryName">
            <summary>Filesystem allows empty string "" directory names.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOptionPath.#ctor(Lexical.FileSystem.FileSystemCaseSensitivity,System.Boolean)">
            <summary>Create path related options</summary>
        </member>
        <member name="T:Lexical.FileSystem.TokenExtensions">
            <summary>
            Token extension methods.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TokenObject(Lexical.FileSystem.IToken)">
            <summary>
            (optional) Get token object
            </summary>
            <param name="tokenContainer"></param>
            <returns>object or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.Key(Lexical.FileSystem.IToken)">
            <summary>
            (optional) Get token type
            </summary>
            <param name="tokenContainer"></param>
            <returns>type or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.Patterns(Lexical.FileSystem.IToken)">
            <summary>
            (optional) Get token path patterns.
            </summary>
            <param name="tokenContainer"></param>
            <returns>type or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetToken(Lexical.FileSystem.IOption,System.String,System.String,System.Object@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetToken``1(Lexical.FileSystem.IOption,System.String,``0@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <typeparamref name="T"/>.
            
            Uses <typeparamref name="T"/>.FullName as Key.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetToken``1(Lexical.FileSystem.IOption,System.String,System.String,``0@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <typeparamref name="T"/>.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetAllTokens(Lexical.FileSystem.IOption,System.String,System.String,System.Object[]@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetAllTokens``1(Lexical.FileSystem.IOption,System.String,``0[]@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <typeparamref name="T"/>.
            
            Uses <typeparamref name="T"/>.FullName as Key.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.TryGetAllTokens``1(Lexical.FileSystem.IOption,System.String,System.String,``0[]@)">
            <summary>
            Query for a token object at path <paramref name="path"/> as type <typeparamref name="T"/>.
            </summary>
            <param name="tokenContainer"></param>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query, typically <see cref="P:System.Type.FullName"/></param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.ListTokens(Lexical.FileSystem.IOption,System.Boolean)">
            <summary>
            If <paramref name="tokenContainer"/> is a single token, then enumerates it.
            If <paramref name="tokenContainer"/> is token collection, then enumerates all contained tokens.
            If <paramref name="recurse"/> is true, then enumerates tree of collections.
            </summary>
            <param name="tokenContainer"></param>
            <param name="recurse"></param>
            <returns>enumerable of tokens</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.Concat(Lexical.FileSystem.IToken,Lexical.FileSystem.IToken)">
            <summary>
            Concatenates two tokens non-recursively.
            Tokens may be null valued.
            </summary>
            <param name="t1">(optional) Token</param>
            <param name="t2">(optional) Token</param>
            <returns>null, t1, t2, or concatenated token</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.Concat(Lexical.FileSystem.IToken,Lexical.FileSystem.IToken,Lexical.FileSystem.IToken)">
            <summary>
            Concatenates three tokens non-recursively.
            Tokens may be null valued.
            </summary>
            <param name="t1">(optional) Token</param>
            <param name="t2">(optional) Token</param>
            <param name="t3">(optional) Token</param>
            <returns>null, t1, t2, or concatenated token</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenExtensions.Concat(Lexical.FileSystem.IToken,Lexical.FileSystem.IToken[])">
            <summary>
            Concatenates tokens non-recursively.
            Tokens may be null valued.
            </summary>
            <param name="t1"></param>
            <param name="moreTokens">(optional) more tokens</param>
            <returns>null, t1, t2, or concatenated token</returns>
        </member>
        <member name="T:Lexical.FileSystem.TokenOperations">
            <summary><see cref="T:Lexical.FileSystem.IToken"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.TokenOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Token">
            <summary>
            Single token container.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Token.TokenObject">
            <summary>(optional) Token object</summary>
        </member>
        <member name="P:Lexical.FileSystem.Token.Key">
            <summary>(optional) Token type as which object is offered.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Token.Patterns">
            <summary>(optional) Path patterns.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Token.TokenAsArray">
            <summary>(optional) Token object</summary>
        </member>
        <member name="F:Lexical.FileSystem.Token.acceptAllPaths">
            <summary>
            Accept all patterns
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Token.matcher">
            <summary>
            Function that tests whether patterns match
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Token.#ctor(System.Object,System.String)">
            <summary>
            Create token container.
            </summary>
            <param name="token"></param>
            <param name="key">(optional) The key <paramref name="token"/> is offered as. If null, then matches to every key criteria in TryGet</param>
        </member>
        <member name="M:Lexical.FileSystem.Token.#ctor(System.Object,System.String,System.String[])">
            <summary>
            Create token container.
            </summary>
            <param name="token"></param>
            <param name="key">(optional) The key <paramref name="token"/> is offered as. If null, then matches to every key criteria in TryGet</param>
            <param name="patterns">(optional) path globa patterns to accept. If null, then accepts every path, which is equal to "**" pattern.</param>
        </member>
        <member name="M:Lexical.FileSystem.Token.TryGetToken(System.String,System.String,System.Object@)">
            <summary>
            Query for first token object at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query</param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.Token.TryGetAllTokens(System.String,System.String,System.Object[]@)">
            <summary>
            Query for all token objects at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query</param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found for the parameters</returns>
        </member>
        <member name="M:Lexical.FileSystem.Token.ToString">
            <summary>Print info</summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.TokenList">
            <summary>
            Readonly list of tokens.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.TokenList.NoTokens">
            <summary>Singleton instance that contains 0 tokens.</summary>
        </member>
        <member name="P:Lexical.FileSystem.TokenList.Count">
            <summary>Token count</summary>
        </member>
        <member name="P:Lexical.FileSystem.TokenList.Item(System.Int32)">
            <summary>Get token at <paramref name="index"/>.</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="F:Lexical.FileSystem.TokenList.tokens">
            <summary>Array of tokens, nulls are removed</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.#ctor(Lexical.FileSystem.IToken,Lexical.FileSystem.IToken)">
            <summary>
            Create a token that combins a pair of tokens.
            Removes null values.
            </summary>
            <param name="token1"></param>
            <param name="token2"></param>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.#ctor(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IToken})">
            <summary>
            Create a token that reads <paramref name="tokens"/> into array of tokens.
            Removes null values.
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.#ctor(Lexical.FileSystem.IToken[])">
            <summary>
            Create token list.
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.TryGetToken(System.String,System.String,System.Object@)">
            <summary>
            Query for first token object at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query with</param>
            <param name="token">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.TryGetAllTokens(System.String,System.String,System.Object[]@)">
            <summary>
            Query for all token objects at path <paramref name="path"/> as type <paramref name="key"/>.
            </summary>
            <param name="path">(optional) path to query token at</param>
            <param name="key">(optional) key to query with</param>
            <param name="tokens">array of tokens, or null if failed to find matching tokens</param>
            <returns>true if tokens were found</returns>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.GetEnumerator">
            <summary>Get enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.TokenList.ToString">
            <summary>Print info</summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoader">
            <summary>
            Interace for loaders that read package files, such as .zip, as <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            The implementing class must implement one or more of the following sub-interfaces:
            <list type="bullet">
               <item><see cref="T:Lexical.FileSystem.Package.IPackageLoaderOpenFile"/></item>
               <item><see cref="T:Lexical.FileSystem.Package.IPackageLoaderLoadFile"/></item>
               <item><see cref="T:Lexical.FileSystem.Package.IPackageLoaderUseStream"/></item>
               <item><see cref="T:Lexical.FileSystem.Package.IPackageLoaderLoadFromStream"/></item>
               <item><see cref="T:Lexical.FileSystem.Package.IPackageLoaderCreate"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoader.FileExtensionPattern">
            <summary>
            The file extension(s) this format can open.
            
            The string is a regular expression. 
            For example "\.zip" or "\.zip|\.7z|\.tar\.gz"
            
            Pattern will be used as case insensitive, so the case doesn't matter, but lower is preferred.
            
            Do not add named groups. For example "(?&lt;name&gt;..)".
            
            Unnamed groups are, however, allowed. For example: "\.zip(\.tmp)?"
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoaderOpenFile">
            <summary>
            Package loader that can open a package file as <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoaderOpenFile.CanOpenFile">
            <summary>
            Can open file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.IPackageLoaderOpenFile.OpenFile(System.String,Lexical.FileSystem.Package.IPackageInfo)">
            <summary>
            Open a package file and keep it open until the file system is disposed. 
            Return <see cref="T:Lexical.FileSystem.IFileSystem"/> that represents the contents of the open file.
            
            The caller is responsible for disposing the returned file system if it implements <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="filepath">data to read from</param>
            <param name="packageInfo">(optional) Information about packge that is being opened</param>
            <returns>file system</returns>
            <exception cref="T:System.Exception">If there was unexpected error, such as IOException</exception>
            <exception cref="T:System.InvalidOperationException">If this load method is not supported.</exception>
            <exception cref="T:System.IO.IOException">Problem with io stream</exception>
            <exception cref="T:Lexical.FileSystem.Package.PackageException.LoadError">The when file format is erronous, package will not be opened as directory.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoaderLoadFile">
            <summary>
            Package loader that cab load a package file completely.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoaderLoadFile.CanLoadFile">
            <summary>
            Can use stream.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.IPackageLoaderLoadFile.LoadFile(System.String,Lexical.FileSystem.Package.IPackageInfo)">
            <summary>
            Load a package file completely. The implementation must close the file before the call returns.
            Return <see cref="T:Lexical.FileSystem.IFileSystem"/> that represents the contents of the open file.
            
            The caller is responsible for disposing the returned file system if it implements <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="filepath">data to read from</param>
            <param name="packageInfo">(optional) Information about packge that is being opened</param>
            <returns>file system</returns>
            <exception cref="T:System.Exception">If there was unexpected error, such as IOException</exception>
            <exception cref="T:System.InvalidOperationException">If this load method is not supported.</exception>
            <exception cref="T:System.IO.IOException">Problem with io stream</exception>
            <exception cref="T:Lexical.FileSystem.Package.PackageException.LoadError">The when file format is erronous, package will not be opened as directory.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoaderUseStream">
            <summary>
            Package loader that can open <see cref="T:System.IO.Stream"/> to access contents of a package file.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoaderUseStream.CanUseStream">
            <summary>
            Can use package from stream.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.IPackageLoaderUseStream.UseStream(System.IO.Stream,Lexical.FileSystem.Package.IPackageInfo)">
            <summary>
            Use an open <paramref name="stream"/> to read contents from a package file.
            Return a <see cref="T:Lexical.FileSystem.IFileSystem"/> that represent the contents.
            
            The returned file system takes ownership of the stream, and must close the <paramref name="stream"/> along with the system.
            
            <paramref name="stream"/> must be readable and seekable, <see cref="P:System.IO.Stream.CanSeek"/> must be true.
            
            The caller is responsible for disposing the returned file system if it implements <see cref="T:System.IDisposable"/>.
            
            Note, open stream cannot be read concurrently from two threads and must be locked with mutually exclusive lock if two reads attempted.
            </summary>
            <param name="stream">stream to read data from. Stream must be disposed along with the returned file system.</param>
            <param name="packageInfo">(optional) Information about packge that is being opened</param>
            <returns>file system that can be disposable</returns>
            <exception cref="T:System.Exception">If there was unexpected error, such as IOException</exception>
            <exception cref="T:System.InvalidOperationException">If this load method is not supported.</exception>
            <exception cref="T:System.IO.IOException">Problem with io stream</exception>
            <exception cref="T:Lexical.FileSystem.Package.PackageException.LoadError">The when file format is erronous, package will not be opened as directory.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoaderLoadFromStream">
            <summary>
            Package loader that can load a package completely from an open <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoaderLoadFromStream.CanLoadFromStream">
            <summary>
            Can load from stream.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.IPackageLoaderLoadFromStream.LoadFromStream(System.IO.Stream,Lexical.FileSystem.Package.IPackageInfo)">
            <summary>
            Read package completely from <paramref name="stream"/> and return representation of contents as <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            The implementation and the returned <see cref="T:Lexical.FileSystem.IFileSystem"/> does not take ownership of the stream. 
            
            The returned file system can be left to be garbage collected and doesn't need to be disposed.
            </summary>
            <param name="stream">stream to read data from. Stream doesn't need to be closed by callee, but is allowed to do so.</param>
            <param name="packageInfo">(optional) Information about packge that is being opened</param>
            <returns>file system</returns>
            <exception cref="T:System.Exception">If there was unexpected error, such as IOException</exception>
            <exception cref="T:System.InvalidOperationException">If this load method is not supported.</exception>
            <exception cref="T:System.IO.IOException">Problem with io stream</exception>
            <exception cref="T:Lexical.FileSystem.Package.PackageException.LoadError">The when file format is erronous, package will not be opened as directory.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageLoaderCreate">
            <summary>
            Package loader that can create new package.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageLoaderCreate.CanCreate">
            <summary>
            Can create package.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.IPackageLoaderCreate.Create(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem)">
            <summary>
            Create new package into <paramref name="parent"/> filesystem as file <paramref name="path"/>.
            
            If optional <paramref name="initialContent"/> is provided, adds all files in it to the package.
            </summary>
            <param name="parent"></param>
            <param name="path"></param>
            <param name="initialContent">(optional) initial files to add</param>
            <returns>the create package file system open</returns>
            <exception cref="T:System.Exception">If there was unexpected error, such as IOException</exception>
            <exception cref="T:System.NotSupportedException">method is not supported.</exception>
            <exception cref="T:System.IO.IOException">Problem with io stream</exception>
            <exception cref="T:Lexical.FileSystem.Package.PackageException.CreateError">When create fails</exception>
        </member>
        <member name="T:Lexical.FileSystem.Package.IPackageInfo">
            <summary>
            Optional hints about the package that is being loaded.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageInfo.Path">
            <summary>
            (optional) Path within parent file system.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageInfo.LastModified">
            <summary>
            (Optional) Last modified UTC date time.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.IPackageInfo.Length">
            <summary>
            File length, or -1 if unknown
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Package.ITempFileProvider">
            <summary>
            Temporary file provider.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.ITempFileProvider.CreateTempFile">
            <summary>
            Create a new unique 0-bytes temp file that is not locked.
            </summary>
            <exception cref="T:System.IO.IOException">if file creation failed</exception>
            <exception cref="T:System.ObjectDisposedException">if provider is disposed</exception>
            <returns>handle with a filename. Caller must dispose after use, which will delete the file if it still exists.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Package.ITempFileHandle">
            <summary>
            A handle to a temp file name. 
            
            Dispose the handle to delete it.
            
            If temp file is locked, Dispose() throws an <see cref="T:System.IO.IOException"/>.
            
            Failed deletion will still be marked as to-be-deleted.
            There is another delete attempt when the parent <see cref="T:Lexical.FileSystem.Package.ITempFileProvider"/> is disposed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.ITempFileHandle.Filename">
            <summary>
            Filename to 0 bytes temp file.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Package.TempFileProviderOptions">
            <summary>
            Options for configuring <see cref="T:Lexical.FileSystem.Package.ITempFileProvider"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.TempFileProviderOptions.Directory">
            <summary>
            Directory to use temp files. Use slash '/' as directory separator for maximum compability.
            
            If directory contains environment variables, such as "%tmp%", then they will be opened.
            If %tmp% environment variable is not found, then the <see cref="T:Lexical.FileSystem.Package.ITempFileProvider"/> implemntation 
            will use replace %tmp% with value from <see cref="M:System.IO.Path.GetTempPath"/>.
            
            If value is null, then the <see cref="T:Lexical.FileSystem.Package.ITempFileProvider"/> implemntation will use <see cref="M:System.IO.Path.GetTempPath"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.TempFileProviderOptions.Prefix">
            <summary>
            Prefix to use to append before file names.
            
            If null then "" is used.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.TempFileProviderOptions.Suffix">
            <summary>
            Suffix to use to append after file names. For example ".tmp"
            
            If null then "" is used.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.ReadFrom(Lexical.FileSystem.Package.TempFileProviderOptions)">
            <summary>
            Copy settings from <paramref name="src"/>.
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.GetHashCode">
            <summary>
            Calculate hashcode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.Equals(System.Object)">
            <summary>
            Compare equal contents.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.Compare(System.Object,System.Object)">
            <summary>
            Equal content comparison that approves nulls and considers two nulls are equal.
            </summary>
            <param name="a">(optional)</param>
            <param name="b">(optional)</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.Clone">
            <summary>
            Create a copy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderOptions.ToString">
            <summary>
            Print info.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Package.TempFileProviderExtensions">
            <summary>
            <see cref="T:Lexical.FileSystem.Package.ITempFileHandle"/> extension methods.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProviderExtensions.DisposeSuppressIOException(Lexical.FileSystem.Package.ITempFileHandle)">
            <summary>
            Alternative Dispose() that suppresses <see cref="T:System.IO.IOException"/>.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="T:Lexical.FileSystem.Package.PackageException">
            <summary>
            Generic <see cref="T:Lexical.FileSystem.Package.IPackageLoader" /> related exception.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.PackageException.packageLoader">
            <summary>
            (optional) Associated package loader.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.PackageException.PackageLoader">
            <summary>
            (optional) Associated package loader.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception,Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Create exception.
            </summary>
            <param name="filesystem">(optional) associated filesystem</param>
            <param name="path">(optional) associated path</param>
            <param name="message">(optional) message</param>
            <param name="innerException">(optional) inner exception</param>
            <param name="packageLoader">(optional) associated package loader</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create exception.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.Package.PackageException.FileError">
            <summary>
            Generic file related error.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.PackageException.FileError.FilePath">
            <summary>
            (Optional) File path that is associated to this error.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.FileError.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception,Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Create file related error.
            </summary>
            <param name="filesystem">(optional) associated filesystem</param>
            <param name="path">(optional) associated path</param>
            <param name="message">(optional) message</param>
            <param name="innerException">(optional) inner exception</param>
            <param name="packageLoader">(optional) associated package loader</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.FileError.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Derialize exception from <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.FileError.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize object data to <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.Package.PackageException.NoSuitableLoadCapability">
            <summary>
            Could not find suitable load capability in <see cref="T:Lexical.FileSystem.Package.IPackageLoader"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.NoSuitableLoadCapability.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception,Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Create load capability error.
            </summary>
            <param name="filesystem">(optional) associated filesystem</param>
            <param name="path">(optional) associated path</param>
            <param name="message">(optional) message</param>
            <param name="innerException">(optional) inner exception</param>
            <param name="packageLoader">(optional) associated package loader</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.NoSuitableLoadCapability.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Derialize exception from <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.Package.PackageException.LoadError">
            <summary>
            Package load failed error.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.LoadError.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception,Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Create load error.
            </summary>
            <param name="filesystem">(optional) associated filesystem</param>
            <param name="path">(optional) associated path</param>
            <param name="message">(optional) message</param>
            <param name="innerException">(optional) inner exception</param>
            <param name="packageLoader">(optional) associated package loader</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.LoadError.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Derialize exception from <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.Package.PackageException.CreateError">
            <summary>
            Package create failed.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.CreateError.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.Exception,Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Create create failed error.
            </summary>
            <param name="filesystem">(optional) associated filesystem</param>
            <param name="path">(optional) associated path</param>
            <param name="message">(optional) message</param>
            <param name="innerException">(optional) inner exception</param>
            <param name="packageLoader">(optional) associated package loader</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.PackageException.CreateError.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Derialize exception from <paramref name="context"/>.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Lexical.FileSystem.PackageLoaderExtensions">
            <summary>
            <see cref="T:Lexical.FileSystem.Package.IPackageLoader"/> extension methods.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.CanOpenFile(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Can open file.
            </summary>
            <param name="packageLoader"></param>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.CanLoadFile(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Can load file.
            </summary>
            <param name="packageLoader"></param>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.IPackageLoaderUseStream(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Can use package from stream.
            </summary>
            <param name="packageLoader"></param>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.CanLoadFromStream(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Can load from stream.
            </summary>
            <param name="packageLoader"></param>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.CanCreate(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Can create package.
            </summary>
            <param name="packageLoader"></param>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.GetExtensions(Lexical.FileSystem.Package.IPackageLoader)">
            <summary>
            Try to read supported file formats from the regular expression pattern.
            </summary>
            <param name="packageLoader"></param>
            <returns>for example "dll"</returns>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.GetExtensions(System.Collections.Generic.IEnumerable{Lexical.FileSystem.Package.IPackageLoader})">
            <summary>
            Try to read supported file formats from the regular expression pattern.
            </summary>
            <param name="packageLoaders"></param>
            <returns>for example "dll", "zip", ... </returns>
        </member>
        <member name="M:Lexical.FileSystem.PackageLoaderExtensions.SortByExtension(System.Collections.Generic.IEnumerable{Lexical.FileSystem.Package.IPackageLoader})">
            <summary>
            Sort packageloaders by the file extensions they support.
            </summary>
            <param name="packageLoaders"></param>
            <returns>map, e.g. { "dll", Dll.Singleton }</returns>
        </member>
        <member name="T:Lexical.FileSystem.AutoMountOptionOperations">
            <summary><see cref="T:Lexical.FileSystem.IOpenOption"/> operations.</summary>
        </member>
        <member name="P:Lexical.FileSystem.AutoMountOptionOperations.OptionType">
            <summary>The option type that this class has operations for.</summary>
        </member>
        <member name="M:Lexical.FileSystem.AutoMountOptionOperations.Flatten(Lexical.FileSystem.IOption)">
            <summary>Flatten to simpler instance.</summary>
        </member>
        <member name="M:Lexical.FileSystem.AutoMountOptionOperations.Intersection(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Intersection of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.AutoMountOptionOperations.Union(Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>Union of <paramref name="o1"/> and <paramref name="o2"/>.</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemOptionPackageLoader">
            <summary>Option for auto-mounted packages.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemOptionPackageLoader.AutoMounters">
            <summary>Package loaders that can mount package files, such as .zip.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOptionPackageLoader.#ctor(Lexical.FileSystem.Package.IPackageLoader[])">
            <summary>Create option for auto-mounted packages.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IBelatableDispose">
            <summary>
            Interface for objects whose dispose can be belated. 
            
            Belating is a reference counting mechanism that is based on disposable handles instead of reference.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBelatableDispose.BelateDispose">
            <summary>
            Post-pone dispose. 
            
            Creates a handle that postpones the dispose of the object until all the belate-handles have been disposed.
            </summary>
            <returns>belating handle that must be diposed</returns>
            <exception cref="T:System.ObjectDisposedException">thrown if object has already been disposed</exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IBlockPool">
            <summary>
            Block pool allocates and recycles memory blocks that are used for buffers.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.BlockSize">
            <summary>Block size, typically 4096</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.MaxBlockCount">
            <summary>Maximum number of blocks to dispence</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.MaxRecycleQueue">
            <summary>Maximum number of blocks to keep in recycle queue</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.ClearsRecycledBlocks">
            <summary>Clears recycled blocks</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.BytesAllocated">
            <summary>Number of bytes allocated</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IBlockPool.BytesAvailable">
            <summary>Number of bytes available for allocation</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.TryAllocate(System.Byte[]@)">
            <summary>
            Try to allocate block, if no blocks are available returns false and null.
            </summary>
            <param name="block"></param>
            <returns>true if <paramref name="block"/> was placed with block, false if there were not free space</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.Allocate">
            <summary>
            Allocate block. If no blocks are available, then waits until one is returned.
            </summary>
            <returns>block</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.Return(System.Byte[])">
            <summary>
            Return <paramref name="block"/> back to the block pool.
            
            If there is a thread waiting to get a block, then the thread is woken up and is distributed the block.
            </summary>
            <param name="block">block to return</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.Return(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Return <paramref name="blocks"/> back to the block pool.
            
            If there is a thread waiting to get a block, then the thread is woken up and provided one.
            </summary>
            <param name="blocks">block to return</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.Disconnect(System.Byte[])">
            <summary>
            Disconnect <paramref name="block"/> from pool. <paramref name="block"/> is a block that has been allocated by the pool earlier on.
            
            The caller gets the ownership of <paramref name="block"/>.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IBlockPool.Disconnect(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Disconnect <paramref name="blocks"/> from the pool. <paramref name="blocks"/> have been allocated by the pool earlier on.
            
            The caller gets the ownership of <paramref name="blocks"/>.
            </summary>
            <param name="blocks"></param>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IDisposeList">
            <summary>
            Object that can be attached with <see cref="T:System.IDisposable"/>.
            They will be disposed along with the object.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IDisposeList.IsDisposeCalled">
            <summary>
            Has Dispose() been called, has dispose started, or has dispose completed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IDisposeList.IsDisposing">
            <summary>
            Has dispose started or completed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IDisposeList.IsDisposed">
            <summary>
            Has dispose completed.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IDisposeList.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposableObject"/> that is to be disposed along with the called object.
            
            If the implementing object has already been disposed, this method immediately disposes the <paramref name="disposableObject"/>.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if was added to list, false if wasn't but was disposed immediately</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IDisposeList.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposableObjects"/> that are going to be disposed along with the called object.
            
            If the implementing object has already been disposed, this method immediately disposes the <paramref name="disposableObjects"/>.
            </summary>
            <param name="disposableObjects"></param>
            <returns>true if were added to list, false if were disposed immediately</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IDisposeList.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposableObject"/> from the list. 
            </summary>
            <param name="disposableObject"></param>
            <returns>true if was removed, false if it wasn't in the list.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IDisposeList.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposableObjects"/> from the list. 
            </summary>
            <param name="disposableObjects"></param>
            <returns>true if was removed, false if it wasn't in the list.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IDisposeList.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the <paramref name="disposeAction"/> is executed immediately.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryPool">
            <summary>
            Memory pool that can lease memory.
            
            See subinterfaces:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.Utility.IMemoryPool`1"/></item>
                <item><see cref="T:Lexical.FileSystem.Utility.IMemoryPoolArray"/></item>
                <item><see cref="T:Lexical.FileSystem.Utility.IMemoryPoolBlock"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryPool.TotalLength">
            <summary>Total amount of bytes available and allocated.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryPool.Allocated">
            <summary>Bytes allocated to leasers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryPool.Available">
            <summary>Available for allocation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryPool.ClearsRecycledBlocks">
            <summary>Policy whether return memory is cleared.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryPool.MemoryTypes">
            <summary><see cref="T:Lexical.FileSystem.Utility.IMemory"/> subtypes that are supported by this pool.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryPool`1">
            <summary>
            Memory pool that can lease memory as <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryPool`1.TryAllocate(System.Int64,`0@)">
            <summary>
            Try to allocate memory, if not enough memory is available, then returns false and null.
            </summary>
            <param name="length"></param>
            <param name="memory"></param>
            <returns>true if <paramref name="memory"/> was placed with block, false if there were not free space</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryPool`1.Allocate(System.Int64)">
            <summary>
            Allocate memory. If not enough memory is available, then waits until there is.
            </summary>
            <returns>block</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryPoolArray">
            <summary>
            Memory pool that can lease byte arrays.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryPoolBlock">
            <summary>
            Memory pool that can lease blocks.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemory">
            <summary>
            Abstract memory block. Dispose to return to pool.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemory.Pool">
            <summary>Leasing pool.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemory.Length">
            <summary>Block length</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryBlock">
            <summary>
            Leased memory block that can be written and read. Dispose to return to pool.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryBlock.Read(System.Int64,System.Int32,System.Byte[])">
            <summary>
            Read from block.
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="buffer"></param>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length.</exception>
            <exception cref="T:System.ObjectDisposedException">object has been returned to the leaser</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryBlock.Write(System.Int64,System.Int32,System.Byte[])">
            <summary>
            Write to block.
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="buffer"></param>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length.</exception>
            <exception cref="T:System.ObjectDisposedException">object has been returned to the leaser</exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryArray">
            <summary>
            Leased memory array. Dispose to return to pool.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.IMemoryArray.Array">
            <summary>Reference to array.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.IMemoryPoolExtensions">
            <summary>
            Memory pool extensions
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryPoolExtensions.TryAllocate``1(Lexical.FileSystem.Utility.IMemoryPool,System.Int64,``0@)">
            <summary>
            Try to allocate memory, if not enough memory is available, then returns false and null.
            </summary>
            <param name="memoryPool"></param>
            <param name="length"></param>
            <param name="memory"></param>
            <returns>true if <paramref name="memory"/> was placed with block, false if there were not free space</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException">if <typeparamref name="T"/> is not supported.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.IMemoryPoolExtensions.Allocate``1(Lexical.FileSystem.Utility.IMemoryPool,System.Int64)">
            <summary>
            Allocate memory. If not enough memory is available, then waits until there is.
            </summary>
            <param name="memoryPool"></param>
            <param name="length"></param>
            <returns>block</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException">if <typeparamref name="T"/> is not supported.</exception>
        </member>
    </members>
</doc>
